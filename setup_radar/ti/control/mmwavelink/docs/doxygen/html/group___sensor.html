<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Sensor</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Sensor</div>  </div>
</div><!--header-->
<div class="contents">

<p>mmwave radar RF/Sensor Configuration Module  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga71a59b160bf9b7a688bad4ed24fdc1f6"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga71a59b160bf9b7a688bad4ed24fdc1f6">rlSetChannelConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_chan_cfg__t.html">rlChanCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga71a59b160bf9b7a688bad4ed24fdc1f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Rx and Tx Channel Configuration.  <a href="#ga71a59b160bf9b7a688bad4ed24fdc1f6">More...</a><br /></td></tr>
<tr class="separator:ga71a59b160bf9b7a688bad4ed24fdc1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf97bc35cf7acd9035b0fcadb00f3ad3"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gadf97bc35cf7acd9035b0fcadb00f3ad3">rlSetAdcOutConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_adc_out_cfg__t.html">rlAdcOutCfg_t</a> *data)</td></tr>
<tr class="memdesc:gadf97bc35cf7acd9035b0fcadb00f3ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets ADC Output Configuration.  <a href="#gadf97bc35cf7acd9035b0fcadb00f3ad3">More...</a><br /></td></tr>
<tr class="separator:gadf97bc35cf7acd9035b0fcadb00f3ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ce12087a177926f8423b5bbc03b5254"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga0ce12087a177926f8423b5bbc03b5254">rlSetLowPowerModeConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_low_power_mode_cfg__t.html">rlLowPowerModeCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga0ce12087a177926f8423b5bbc03b5254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Low Power Mode Configuration.  <a href="#ga0ce12087a177926f8423b5bbc03b5254">More...</a><br /></td></tr>
<tr class="separator:ga0ce12087a177926f8423b5bbc03b5254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga958481166a629f374684c680904d5146"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga958481166a629f374684c680904d5146">rlRfInit</a> (rlUInt8_t deviceMap)</td></tr>
<tr class="memdesc:ga958481166a629f374684c680904d5146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the RF/Analog Subsystem.  <a href="#ga958481166a629f374684c680904d5146">More...</a><br /></td></tr>
<tr class="separator:ga958481166a629f374684c680904d5146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52dfab9a128a66d75e51bf4d741a424b"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga52dfab9a128a66d75e51bf4d741a424b">rlGetProfileConfig</a> (rlUInt8_t deviceMap, rlUInt16_t profileId, <a class="el" href="structrl_profile_cfg__t.html">rlProfileCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga52dfab9a128a66d75e51bf4d741a424b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets Chirp profile Configuration.  <a href="#ga52dfab9a128a66d75e51bf4d741a424b">More...</a><br /></td></tr>
<tr class="separator:ga52dfab9a128a66d75e51bf4d741a424b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadd84f565083150a4c09b28f77cf4294"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gaadd84f565083150a4c09b28f77cf4294">rlSetProfileConfig</a> (rlUInt8_t deviceMap, rlUInt16_t cnt, <a class="el" href="structrl_profile_cfg__t.html">rlProfileCfg_t</a> *data)</td></tr>
<tr class="memdesc:gaadd84f565083150a4c09b28f77cf4294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Chirp profile Configuration.  <a href="#gaadd84f565083150a4c09b28f77cf4294">More...</a><br /></td></tr>
<tr class="separator:gaadd84f565083150a4c09b28f77cf4294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf441aded0e05ef3139df6b1fe2a607ed"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gaf441aded0e05ef3139df6b1fe2a607ed">rlGetChirpConfig</a> (rlUInt8_t deviceMap, rlUInt16_t chirpStartIdx, rlUInt16_t chirpEndIdx, <a class="el" href="structrl_chirp_cfg__t.html">rlChirpCfg_t</a> *data)</td></tr>
<tr class="memdesc:gaf441aded0e05ef3139df6b1fe2a607ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets Chirp Configuration.  <a href="#gaf441aded0e05ef3139df6b1fe2a607ed">More...</a><br /></td></tr>
<tr class="separator:gaf441aded0e05ef3139df6b1fe2a607ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02aca718122731c4376e25eeefe6ed5e"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga02aca718122731c4376e25eeefe6ed5e">rlSetChirpConfig</a> (rlUInt8_t deviceMap, rlUInt16_t cnt, <a class="el" href="structrl_chirp_cfg__t.html">rlChirpCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga02aca718122731c4376e25eeefe6ed5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Chirp Configuration.  <a href="#ga02aca718122731c4376e25eeefe6ed5e">More...</a><br /></td></tr>
<tr class="separator:ga02aca718122731c4376e25eeefe6ed5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabedb7c157bd33891293ad2f99bad138"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gaabedb7c157bd33891293ad2f99bad138">rlSetMultiChirpCfg</a> (rlUInt8_t deviceMap, rlUInt16_t cnt, <a class="el" href="structrl_chirp_cfg__t.html">rlChirpCfg_t</a> **data)</td></tr>
<tr class="memdesc:gaabedb7c157bd33891293ad2f99bad138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects chirp configuration to be programmed dynamically.  <a href="#gaabedb7c157bd33891293ad2f99bad138">More...</a><br /></td></tr>
<tr class="separator:gaabedb7c157bd33891293ad2f99bad138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7619b9244bcee4f602cf3f4f995394c8"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga7619b9244bcee4f602cf3f4f995394c8">rlGetFrameConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_frame_cfg__t.html">rlFrameCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga7619b9244bcee4f602cf3f4f995394c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets Frame Configuration.  <a href="#ga7619b9244bcee4f602cf3f4f995394c8">More...</a><br /></td></tr>
<tr class="separator:ga7619b9244bcee4f602cf3f4f995394c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1e5cbc25891714db321da3bfa0d2014"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gaf1e5cbc25891714db321da3bfa0d2014">rlSetFrameConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_frame_cfg__t.html">rlFrameCfg_t</a> *data)</td></tr>
<tr class="memdesc:gaf1e5cbc25891714db321da3bfa0d2014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Frame Configuration.  <a href="#gaf1e5cbc25891714db321da3bfa0d2014">More...</a><br /></td></tr>
<tr class="separator:gaf1e5cbc25891714db321da3bfa0d2014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ce3a292815faac84048977ad29658cd"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga4ce3a292815faac84048977ad29658cd">rlSensorStart</a> (rlUInt8_t deviceMap)</td></tr>
<tr class="memdesc:ga4ce3a292815faac84048977ad29658cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggers Transmission of Frames.  <a href="#ga4ce3a292815faac84048977ad29658cd">More...</a><br /></td></tr>
<tr class="separator:ga4ce3a292815faac84048977ad29658cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ed5478211ce88b74498e7978e200986"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga3ed5478211ce88b74498e7978e200986">rlSensorStop</a> (rlUInt8_t deviceMap)</td></tr>
<tr class="memdesc:ga3ed5478211ce88b74498e7978e200986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops Transmission of Frames.  <a href="#ga3ed5478211ce88b74498e7978e200986">More...</a><br /></td></tr>
<tr class="separator:ga3ed5478211ce88b74498e7978e200986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga065915b702d27bda849435010af80a97"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga065915b702d27bda849435010af80a97">rlFrameStartStop</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_frame_trigger__t.html">rlFrameTrigger_t</a> *data)</td></tr>
<tr class="memdesc:ga065915b702d27bda849435010af80a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggers/Stops Transmission of Frames.  <a href="#ga065915b702d27bda849435010af80a97">More...</a><br /></td></tr>
<tr class="separator:ga065915b702d27bda849435010af80a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12e48d543221c5e1312a6bb73d209ffe"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga12e48d543221c5e1312a6bb73d209ffe">rlGetAdvFrameConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_adv_frame_cfg__t.html">rlAdvFrameCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga12e48d543221c5e1312a6bb73d209ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets Advance Frame Configuration.  <a href="#ga12e48d543221c5e1312a6bb73d209ffe">More...</a><br /></td></tr>
<tr class="separator:ga12e48d543221c5e1312a6bb73d209ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga260d9e27b7b75c3cd33266a16f197ce7"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga260d9e27b7b75c3cd33266a16f197ce7">rlSetAdvFrameConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_adv_frame_cfg__t.html">rlAdvFrameCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga260d9e27b7b75c3cd33266a16f197ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Advance Frame Configuration.  <a href="#ga260d9e27b7b75c3cd33266a16f197ce7">More...</a><br /></td></tr>
<tr class="separator:ga260d9e27b7b75c3cd33266a16f197ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7436761acc24664420be7cc4561e3757"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga7436761acc24664420be7cc4561e3757">rlSetContModeConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_cont_mode_cfg__t.html">rlContModeCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga7436761acc24664420be7cc4561e3757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Continous mode Configuration.  <a href="#ga7436761acc24664420be7cc4561e3757">More...</a><br /></td></tr>
<tr class="separator:ga7436761acc24664420be7cc4561e3757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65ff62ce5e024634fdc18df53dedf502"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga65ff62ce5e024634fdc18df53dedf502">rlEnableContMode</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_cont_mode_en__t.html">rlContModeEn_t</a> *data)</td></tr>
<tr class="memdesc:ga65ff62ce5e024634fdc18df53dedf502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable Continous mode.  <a href="#ga65ff62ce5e024634fdc18df53dedf502">More...</a><br /></td></tr>
<tr class="separator:ga65ff62ce5e024634fdc18df53dedf502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1e0e3e2b0cf4ba51b6f14b42f3ae173"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gab1e0e3e2b0cf4ba51b6f14b42f3ae173">rlSetBpmCommonConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_bpm_common_cfg__t.html">rlBpmCommonCfg_t</a> *data)</td></tr>
<tr class="memdesc:gab1e0e3e2b0cf4ba51b6f14b42f3ae173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Binary Phase Modulation Common Configuration.  <a href="#gab1e0e3e2b0cf4ba51b6f14b42f3ae173">More...</a><br /></td></tr>
<tr class="separator:gab1e0e3e2b0cf4ba51b6f14b42f3ae173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ed1335fefa3bf89690418cfe6a379bd"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga8ed1335fefa3bf89690418cfe6a379bd">rlSetBpmChirpConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_bpm_chirp_cfg__t.html">rlBpmChirpCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga8ed1335fefa3bf89690418cfe6a379bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Binary Phase Modulation Chirp Configuration.  <a href="#ga8ed1335fefa3bf89690418cfe6a379bd">More...</a><br /></td></tr>
<tr class="separator:ga8ed1335fefa3bf89690418cfe6a379bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9588a836954d95b432b5755dad11243d"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga9588a836954d95b432b5755dad11243d">rlSetMultiBpmChirpConfig</a> (rlUInt8_t deviceMap, rlUInt16_t cnt, <a class="el" href="structrl_bpm_chirp_cfg__t.html">rlBpmChirpCfg_t</a> **data)</td></tr>
<tr class="memdesc:ga9588a836954d95b432b5755dad11243d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Binary Phase Modulation configuration for multiple Chirp.  <a href="#ga9588a836954d95b432b5755dad11243d">More...</a><br /></td></tr>
<tr class="separator:ga9588a836954d95b432b5755dad11243d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5d3076ae4314c75470c5f4c0339ea8b"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gae5d3076ae4314c75470c5f4c0339ea8b">rlSetTestSourceConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_test_source__t.html">rlTestSource_t</a> *data)</td></tr>
<tr class="memdesc:gae5d3076ae4314c75470c5f4c0339ea8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the Test Source.  <a href="#gae5d3076ae4314c75470c5f4c0339ea8b">More...</a><br /></td></tr>
<tr class="separator:gae5d3076ae4314c75470c5f4c0339ea8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cf47018653eb8cbd49adfccf0fc6ef9"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga0cf47018653eb8cbd49adfccf0fc6ef9">rlTestSourceEnable</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_test_source_enable__t.html">rlTestSourceEnable_t</a> *data)</td></tr>
<tr class="memdesc:ga0cf47018653eb8cbd49adfccf0fc6ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Test Source.  <a href="#ga0cf47018653eb8cbd49adfccf0fc6ef9">More...</a><br /></td></tr>
<tr class="separator:ga0cf47018653eb8cbd49adfccf0fc6ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga335113f6e1e6c260dcd03e03a0932a1b"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga335113f6e1e6c260dcd03e03a0932a1b">rlRfGetTemperatureReport</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_temp_data__t.html">rlRfTempData_t</a> *data)</td></tr>
<tr class="memdesc:ga335113f6e1e6c260dcd03e03a0932a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets Time and Temperature information report.  <a href="#ga335113f6e1e6c260dcd03e03a0932a1b">More...</a><br /></td></tr>
<tr class="separator:ga335113f6e1e6c260dcd03e03a0932a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39cf05329fbbf5783f53d8f80644e3ff"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga39cf05329fbbf5783f53d8f80644e3ff">rlRfDfeRxStatisticsReport</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_dfe_stat_report__t.html">rlDfeStatReport_t</a> *data)</td></tr>
<tr class="memdesc:ga39cf05329fbbf5783f53d8f80644e3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets Digital Front end statistics such as Residual DC, RMS power in I and Q chains for different Receive channels for different selected profiles. It also includes Cross correlation between I and Q chains.  <a href="#ga39cf05329fbbf5783f53d8f80644e3ff">More...</a><br /></td></tr>
<tr class="separator:ga39cf05329fbbf5783f53d8f80644e3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fa427b370b330f4c559793d2df92691"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga6fa427b370b330f4c559793d2df92691">rlRfDynamicPowerSave</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_dyn_pwr_save__t.html">rlDynPwrSave_t</a> *data)</td></tr>
<tr class="memdesc:ga6fa427b370b330f4c559793d2df92691"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Configure dynamic power saving feature.  <a href="#ga6fa427b370b330f4c559793d2df92691">More...</a><br /></td></tr>
<tr class="separator:ga6fa427b370b330f4c559793d2df92691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25ff76b7e26d26a184fd1c778cb4bf2f"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga25ff76b7e26d26a184fd1c778cb4bf2f">rlRfSetDeviceCfg</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_dev_cfg__t.html">rlRfDevCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga25ff76b7e26d26a184fd1c778cb4bf2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Set different RadarSS device configurations  <a href="#ga25ff76b7e26d26a184fd1c778cb4bf2f">More...</a><br /></td></tr>
<tr class="separator:ga25ff76b7e26d26a184fd1c778cb4bf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed3f172d9edbee35db9520b87485f525"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gaed3f172d9edbee35db9520b87485f525">rlSetGpAdcConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_gp_adc_cfg__t.html">rlGpAdcCfg_t</a> *data)</td></tr>
<tr class="memdesc:gaed3f172d9edbee35db9520b87485f525"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Configure GP ADC data parameters  <a href="#gaed3f172d9edbee35db9520b87485f525">More...</a><br /></td></tr>
<tr class="separator:gaed3f172d9edbee35db9520b87485f525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9450d508e0fa2857f8f9cb6b5004ecc"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gaf9450d508e0fa2857f8f9cb6b5004ecc">rlRfSetPhaseShiftConfig</a> (rlUInt8_t deviceMap, rlUInt16_t cnt, <a class="el" href="structrl_rf_phase_shift_cfg__t.html">rlRfPhaseShiftCfg_t</a> *data)</td></tr>
<tr class="memdesc:gaf9450d508e0fa2857f8f9cb6b5004ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable phase shift configurations per chirp in each of the TXs.  <a href="#gaf9450d508e0fa2857f8f9cb6b5004ecc">More...</a><br /></td></tr>
<tr class="separator:gaf9450d508e0fa2857f8f9cb6b5004ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e53c805ac1b08ec8939dfe3205fe359"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga9e53c805ac1b08ec8939dfe3205fe359">rlRfSetPALoopbackConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_p_a_loopback_cfg__t.html">rlRfPALoopbackCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga9e53c805ac1b08ec8939dfe3205fe359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable PA loopback for all enabled profiles.  <a href="#ga9e53c805ac1b08ec8939dfe3205fe359">More...</a><br /></td></tr>
<tr class="separator:ga9e53c805ac1b08ec8939dfe3205fe359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78dfcfa4b7fb299434d22edcedb4746d"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga78dfcfa4b7fb299434d22edcedb4746d">rlRfSetPSLoopbackConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_p_s_loopback_cfg__t.html">rlRfPSLoopbackCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga78dfcfa4b7fb299434d22edcedb4746d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable Phase shift loopback for all enabled profiles.  <a href="#ga78dfcfa4b7fb299434d22edcedb4746d">More...</a><br /></td></tr>
<tr class="separator:ga78dfcfa4b7fb299434d22edcedb4746d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd9d2dcea706ab65fe6b949e2008c6ed"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gafd9d2dcea706ab65fe6b949e2008c6ed">rlRfSetIFLoopbackConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_i_f_loopback_cfg__t.html">rlRfIFLoopbackCfg_t</a> *data)</td></tr>
<tr class="memdesc:gafd9d2dcea706ab65fe6b949e2008c6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable RF IF loopback for all enabled profiles. This is used for debug to check if both TX and RX chains are working correctly.  <a href="#gafd9d2dcea706ab65fe6b949e2008c6ed">More...</a><br /></td></tr>
<tr class="separator:gafd9d2dcea706ab65fe6b949e2008c6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76d9fa9dcd3af870a2bb46f6f1b5e8f2"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga76d9fa9dcd3af870a2bb46f6f1b5e8f2">rlRfSetProgFiltCoeffRam</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_prog_filt_coeff__t.html">rlRfProgFiltCoeff_t</a> *data)</td></tr>
<tr class="memdesc:ga76d9fa9dcd3af870a2bb46f6f1b5e8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Programmable Filter coefficient RAM.  <a href="#ga76d9fa9dcd3af870a2bb46f6f1b5e8f2">More...</a><br /></td></tr>
<tr class="separator:ga76d9fa9dcd3af870a2bb46f6f1b5e8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga935fe658cc0e519559c6f705dfeb9297"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga935fe658cc0e519559c6f705dfeb9297">rlRfSetProgFiltConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_prog_filt_conf__t.html">rlRfProgFiltConf_t</a> *data)</td></tr>
<tr class="memdesc:ga935fe658cc0e519559c6f705dfeb9297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Programmable Filter configuration.  <a href="#ga935fe658cc0e519559c6f705dfeb9297">More...</a><br /></td></tr>
<tr class="separator:ga935fe658cc0e519559c6f705dfeb9297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c3ef75c1d3da0a4134f6929107930e8"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga8c3ef75c1d3da0a4134f6929107930e8">rlRfSetMiscConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_misc_conf__t.html">rlRfMiscConf_t</a> *data)</td></tr>
<tr class="memdesc:ga8c3ef75c1d3da0a4134f6929107930e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets misc feature such as per chirp phase shifter.  <a href="#ga8c3ef75c1d3da0a4134f6929107930e8">More...</a><br /></td></tr>
<tr class="separator:ga8c3ef75c1d3da0a4134f6929107930e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ff25a87cf2f34635bb469d3df1d48ed"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga0ff25a87cf2f34635bb469d3df1d48ed">rlRfSetCalMonTimeUnitConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_cal_mon_time_unt_conf__t.html">rlRfCalMonTimeUntConf_t</a> *data)</td></tr>
<tr class="memdesc:ga0ff25a87cf2f34635bb469d3df1d48ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Calibration monitoring time unit.  <a href="#ga0ff25a87cf2f34635bb469d3df1d48ed">More...</a><br /></td></tr>
<tr class="separator:ga0ff25a87cf2f34635bb469d3df1d48ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga012ff7b3e35f35373169b62e4227ce06"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga012ff7b3e35f35373169b62e4227ce06">rlRfSetCalMonFreqLimitConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_cal_mon_freq_limit_conf__t.html">rlRfCalMonFreqLimitConf_t</a> *data)</td></tr>
<tr class="memdesc:ga012ff7b3e35f35373169b62e4227ce06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Calibration monitoring Frequency Limit.  <a href="#ga012ff7b3e35f35373169b62e4227ce06">More...</a><br /></td></tr>
<tr class="separator:ga012ff7b3e35f35373169b62e4227ce06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc0c70e4c766a79ec281f969d0c61561"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gabc0c70e4c766a79ec281f969d0c61561">rlRfInitCalibConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_init_cal_conf__t.html">rlRfInitCalConf_t</a> *data)</td></tr>
<tr class="memdesc:gabc0c70e4c766a79ec281f969d0c61561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set RF Init Calibration Mask bits and report type.  <a href="#gabc0c70e4c766a79ec281f969d0c61561">More...</a><br /></td></tr>
<tr class="separator:gabc0c70e4c766a79ec281f969d0c61561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab47b62709a01f0ba5bdcf3f804dd5a1a"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gab47b62709a01f0ba5bdcf3f804dd5a1a">rlRfRunTimeCalibConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_run_time_calib_conf__t.html">rlRunTimeCalibConf_t</a> *data)</td></tr>
<tr class="memdesc:gab47b62709a01f0ba5bdcf3f804dd5a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set RF one time &amp; periodic calibration of various RF/analog aspects and trigger.  <a href="#gab47b62709a01f0ba5bdcf3f804dd5a1a">More...</a><br /></td></tr>
<tr class="separator:gab47b62709a01f0ba5bdcf3f804dd5a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae35c3687d353c0fb6ad2a9cc08ccff3c"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gae35c3687d353c0fb6ad2a9cc08ccff3c">rlRxGainTempLutSet</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rx_gain_temp_lut_data__t.html">rlRxGainTempLutData_t</a> *data)</td></tr>
<tr class="memdesc:gae35c3687d353c0fb6ad2a9cc08ccff3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite RX gain temperature Lookup Table(LUT) in Radar SS.  <a href="#gae35c3687d353c0fb6ad2a9cc08ccff3c">More...</a><br /></td></tr>
<tr class="separator:gae35c3687d353c0fb6ad2a9cc08ccff3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae129023dfe4ed79d5df1c1001ada7985"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gae129023dfe4ed79d5df1c1001ada7985">rlTxGainTempLutSet</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_tx_gain_temp_lut_data__t.html">rlTxGainTempLutData_t</a> *data)</td></tr>
<tr class="memdesc:gae129023dfe4ed79d5df1c1001ada7985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites TX gain temperature based Lookup table (LUT)  <a href="#gae129023dfe4ed79d5df1c1001ada7985">More...</a><br /></td></tr>
<tr class="separator:gae129023dfe4ed79d5df1c1001ada7985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga938c6847f8a19336019883723c1e214c"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga938c6847f8a19336019883723c1e214c">rlRfTxFreqPwrLimitConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_tx_freq_pwr_limit_mon_conf__t.html">rlRfTxFreqPwrLimitMonConf_t</a> *data)</td></tr>
<tr class="memdesc:ga938c6847f8a19336019883723c1e214c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the limits for RF frequency transmission for each TX and also TX power limits.  <a href="#ga938c6847f8a19336019883723c1e214c">More...</a><br /></td></tr>
<tr class="separator:ga938c6847f8a19336019883723c1e214c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26c4e8543f1b2c6acdab8714e77220d7"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga26c4e8543f1b2c6acdab8714e77220d7">rlSetLoopBckBurstCfg</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_loopback_burst__t.html">rlLoopbackBurst_t</a> *data)</td></tr>
<tr class="memdesc:ga26c4e8543f1b2c6acdab8714e77220d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to introduce loopback chirps within the functional frames.  <a href="#ga26c4e8543f1b2c6acdab8714e77220d7">More...</a><br /></td></tr>
<tr class="separator:ga26c4e8543f1b2c6acdab8714e77220d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga894bc8ce4536062a05aac4248334c964"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga894bc8ce4536062a05aac4248334c964">rlSetDynChirpCfg</a> (rlUInt8_t deviceMap, rlUInt16_t segCnt, <a class="el" href="structrl_dyn_chirp_cfg__t.html">rlDynChirpCfg_t</a> **data)</td></tr>
<tr class="memdesc:ga894bc8ce4536062a05aac4248334c964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects chirp configuration to be programmed dynamically.  <a href="#ga894bc8ce4536062a05aac4248334c964">More...</a><br /></td></tr>
<tr class="separator:ga894bc8ce4536062a05aac4248334c964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac24c37a764127e473cfa9c81320b31e9"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gac24c37a764127e473cfa9c81320b31e9">rlSetDynChirpEn</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_dyn_chirp_en_cfg__t.html">rlDynChirpEnCfg_t</a> *data)</td></tr>
<tr class="memdesc:gac24c37a764127e473cfa9c81320b31e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggers copy of chirp config from SW to HW RAM.  <a href="#gac24c37a764127e473cfa9c81320b31e9">More...</a><br /></td></tr>
<tr class="separator:gac24c37a764127e473cfa9c81320b31e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37cb66bac3ce58d418d45a9e0ad26e53"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga37cb66bac3ce58d418d45a9e0ad26e53">rlSetDynPerChirpPhShifterCfg</a> (rlUInt8_t deviceMap, rlUInt16_t segCnt, <a class="el" href="structrl_dyn_per_chirp_ph_shft_cfg__t.html">rlDynPerChirpPhShftCfg_t</a> **data)</td></tr>
<tr class="memdesc:ga37cb66bac3ce58d418d45a9e0ad26e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects per-chirp phase shifter configuration to be applied dynamically.  <a href="#ga37cb66bac3ce58d418d45a9e0ad26e53">More...</a><br /></td></tr>
<tr class="separator:ga37cb66bac3ce58d418d45a9e0ad26e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed333a050ab0ff53b5ab5a808e715a5c"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gaed333a050ab0ff53b5ab5a808e715a5c">rlRfCalibDataStore</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_calibration_data__t.html">rlCalibrationData_t</a> *data)</td></tr>
<tr class="memdesc:gaed333a050ab0ff53b5ab5a808e715a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read calibration data from the device.  <a href="#gaed333a050ab0ff53b5ab5a808e715a5c">More...</a><br /></td></tr>
<tr class="separator:gaed333a050ab0ff53b5ab5a808e715a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f501504c14a199cb1c9a7073e545acd"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga0f501504c14a199cb1c9a7073e545acd">rlRfCalibDataRestore</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_calibration_data__t.html">rlCalibrationData_t</a> *data)</td></tr>
<tr class="memdesc:ga0f501504c14a199cb1c9a7073e545acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects calibration data to the device.  <a href="#ga0f501504c14a199cb1c9a7073e545acd">More...</a><br /></td></tr>
<tr class="separator:ga0f501504c14a199cb1c9a7073e545acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga401d0fb21dcf7d34bea938b2cd74e5ba"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga401d0fb21dcf7d34bea938b2cd74e5ba">rlRfInterRxGainPhaseConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_inter_rx_gain_ph_conf__t.html">rlInterRxGainPhConf_t</a> *data)</td></tr>
<tr class="memdesc:ga401d0fb21dcf7d34bea938b2cd74e5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets different Rx gain/phase offset.  <a href="#ga401d0fb21dcf7d34bea938b2cd74e5ba">More...</a><br /></td></tr>
<tr class="separator:ga401d0fb21dcf7d34bea938b2cd74e5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67c4baf29d7b1cfb475052cf9a432b83"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga67c4baf29d7b1cfb475052cf9a432b83">rlGetRfBootupStatus</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_boot_status_cfg__t.html">rlRfBootStatusCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga67c4baf29d7b1cfb475052cf9a432b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get radarSS bootup status.  <a href="#ga67c4baf29d7b1cfb475052cf9a432b83">More...</a><br /></td></tr>
<tr class="separator:ga67c4baf29d7b1cfb475052cf9a432b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b6120aed27414c89bc5d27a0e9a22d6"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga3b6120aed27414c89bc5d27a0e9a22d6">rlSetInterChirpBlkCtrl</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_inter_chirp_blk_ctrl_cfg__t.html">rlInterChirpBlkCtrlCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga3b6120aed27414c89bc5d27a0e9a22d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Inter-chip turn on and turn off times or various RF blocks.  <a href="#ga3b6120aed27414c89bc5d27a0e9a22d6">More...</a><br /></td></tr>
<tr class="separator:ga3b6120aed27414c89bc5d27a0e9a22d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0ac5048a8bc47744a685c8db2b9a3e7"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gad0ac5048a8bc47744a685c8db2b9a3e7">rlSetSubFrameStart</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_sub_frame_start_cfg__t.html">rlSubFrameStartCfg_t</a> *data)</td></tr>
<tr class="memdesc:gad0ac5048a8bc47744a685c8db2b9a3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggers the next sub-frame in software triggered sub-frame mode.  <a href="#gad0ac5048a8bc47744a685c8db2b9a3e7">More...</a><br /></td></tr>
<tr class="separator:gad0ac5048a8bc47744a685c8db2b9a3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00f3f0bee9ac7b8f6e35b8df1658158d"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga00f3f0bee9ac7b8f6e35b8df1658158d">rlRfPhShiftCalibDataStore</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_ph_shift_calibration_data__t.html">rlPhShiftCalibrationData_t</a> *data)</td></tr>
<tr class="memdesc:ga00f3f0bee9ac7b8f6e35b8df1658158d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read calibration data from the device.  <a href="#ga00f3f0bee9ac7b8f6e35b8df1658158d">More...</a><br /></td></tr>
<tr class="separator:ga00f3f0bee9ac7b8f6e35b8df1658158d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8983749694adc19bcc2fdf9144cfa0a4"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga8983749694adc19bcc2fdf9144cfa0a4">rlRfPhShiftCalibDataRestore</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_ph_shift_calibration_data__t.html">rlPhShiftCalibrationData_t</a> *data)</td></tr>
<tr class="memdesc:ga8983749694adc19bcc2fdf9144cfa0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects phase shifter calibration data to the device.  <a href="#ga8983749694adc19bcc2fdf9144cfa0a4">More...</a><br /></td></tr>
<tr class="separator:ga8983749694adc19bcc2fdf9144cfa0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga333b50fae881b6e9de6700be35e3836e"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga333b50fae881b6e9de6700be35e3836e">rlGetRfDieId</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_die_id_cfg__t.html">rlRfDieIdCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga333b50fae881b6e9de6700be35e3836e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get device die ID status.  <a href="#ga333b50fae881b6e9de6700be35e3836e">More...</a><br /></td></tr>
<tr class="separator:ga333b50fae881b6e9de6700be35e3836e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eeb5e099b9e310c7b1f5aae27289822"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga5eeb5e099b9e310c7b1f5aae27289822">rlRfGetEsmFault</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_bss_esm_fault__t.html">rlBssEsmFault_t</a> *data)</td></tr>
<tr class="memdesc:ga5eeb5e099b9e310c7b1f5aae27289822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get RadarSS ESM fault status.  <a href="#ga5eeb5e099b9e310c7b1f5aae27289822">More...</a><br /></td></tr>
<tr class="separator:ga5eeb5e099b9e310c7b1f5aae27289822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54ab920ef9fb4e46657d774ef491cb9d"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga54ab920ef9fb4e46657d774ef491cb9d">rlRfGetCpuFault</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_cpu_fault__t.html">rlCpuFault_t</a> *data)</td></tr>
<tr class="memdesc:ga54ab920ef9fb4e46657d774ef491cb9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get RadarSS CPU fault status.  <a href="#ga54ab920ef9fb4e46657d774ef491cb9d">More...</a><br /></td></tr>
<tr class="separator:ga54ab920ef9fb4e46657d774ef491cb9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c1fe92af102850c9889e77437159a80"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga3c1fe92af102850c9889e77437159a80">rlSetAdvChirpConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_adv_chirp_cfg__t.html">rlAdvChirpCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga3c1fe92af102850c9889e77437159a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Advanced chirp configuration to the device.  <a href="#ga3c1fe92af102850c9889e77437159a80">More...</a><br /></td></tr>
<tr class="separator:ga3c1fe92af102850c9889e77437159a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7db78d5d4c9f0af5100ce685eb0675db"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga7db78d5d4c9f0af5100ce685eb0675db">rlMonTypeTrigConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_mon_type_trig_cfg__t.html">rlMonTypeTrigCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga7db78d5d4c9f0af5100ce685eb0675db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintains monitoring timing synchronization in cascaded devices to avoid mutual interference of monitors running in different devices in the cascade sensor.  <a href="#ga7db78d5d4c9f0af5100ce685eb0675db">More...</a><br /></td></tr>
<tr class="separator:ga7db78d5d4c9f0af5100ce685eb0675db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba5f6d1fc69ec1cf5769351a10996bfc"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gaba5f6d1fc69ec1cf5769351a10996bfc">rlRfApllSynthBwCtlConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_apll_synth_bw_control__t.html">rlRfApllSynthBwControl_t</a> *data)</td></tr>
<tr class="memdesc:gaba5f6d1fc69ec1cf5769351a10996bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control bandwidth of the APLL and Synthesizer.  <a href="#gaba5f6d1fc69ec1cf5769351a10996bfc">More...</a><br /></td></tr>
<tr class="separator:gaba5f6d1fc69ec1cf5769351a10996bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fa71180355fd68a6b87bed87b39ef6c"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga0fa71180355fd68a6b87bed87b39ef6c">rlSetAdvChirpLUTConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_adv_chirp_l_u_t_cfg__t.html">rlAdvChirpLUTCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga0fa71180355fd68a6b87bed87b39ef6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Advanced chirp LUT configuration to the device.  <a href="#ga0fa71180355fd68a6b87bed87b39ef6c">More...</a><br /></td></tr>
<tr class="separator:ga0fa71180355fd68a6b87bed87b39ef6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac234ba46f1f41d506f6f231e3ed4540d"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gac234ba46f1f41d506f6f231e3ed4540d">rlSetMultiAdvChirpLUTConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_adv_chirp_l_u_t_cfg__t.html">rlAdvChirpLUTCfg_t</a> *AdvChirpLUTCfgArgs, rlInt8_t *AdvChirpLUTData)</td></tr>
<tr class="memdesc:gac234ba46f1f41d506f6f231e3ed4540d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi Advanced chirp LUT configuration API.  <a href="#gac234ba46f1f41d506f6f231e3ed4540d">More...</a><br /></td></tr>
<tr class="separator:gac234ba46f1f41d506f6f231e3ed4540d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6db6ccd30ed226d5574913adfc6f39a0"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga6db6ccd30ed226d5574913adfc6f39a0">rlSetAdvChirpDynLUTAddrOffConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_adv_chirp_dyn_l_u_t_addr_off_cfg__t.html">rlAdvChirpDynLUTAddrOffCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga6db6ccd30ed226d5574913adfc6f39a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure LUT address offset dynamically for each chirp parameters defined in <a class="el" href="group___sensor.html#ga3c1fe92af102850c9889e77437159a80">rlSetAdvChirpConfig</a> API.  <a href="#ga6db6ccd30ed226d5574913adfc6f39a0">More...</a><br /></td></tr>
<tr class="separator:ga6db6ccd30ed226d5574913adfc6f39a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>mmwave radar RF/Sensor Configuration Module </p>
<div class="image">
<img src="mmwave_frontend.png" alt="mmwave_frontend.png"/>
</div>
<p>The RF/Sensor Configuration module controls the different HW blocks inside mmWave Front end. mmWave Front End has below key blocks</p><ol type="1">
<li>Chirp sequencer (Radar Timing Engine) - This block is responsible for constructing the sequence of FMCW chirps or frames and programming the timing engine</li>
<li>Rx/Tx Channel - This defines how many Rx and Tx channel needs to be enabled. Also it defines how to configure the mmWave front end in cascade mode for Imaging Radar</li>
<li>Rx Analog Chain - This defines how the received signal is mixed and how different filters in the chain can be configured</li>
<li>ADC and Digital Front End Configuration - This defines how the IF data is digitized and how it is sampled for further processing in the DSP or Hardware Accelerator. Same ADC data can be sent over LVDS/CSI2 interface to an extenal processor</li>
</ol>
<p>The Sensor Control APIs needs to be called by application in below sequence </p><h2>Initial/Static Configuration</h2>
<p>Application should first configure the mmWave Front end or Radar SS with below Static configurations</p><ul>
<li>Channel Configuration - <a class="el" href="group___sensor.html#ga71a59b160bf9b7a688bad4ed24fdc1f6">rlSetChannelConfig</a></li>
<li>ADC output Configuration - <a class="el" href="group___sensor.html#gadf97bc35cf7acd9035b0fcadb00f3ad3">rlSetAdcOutConfig</a></li>
<li>Low power mode Configuration - <a class="el" href="group___sensor.html#ga0ce12087a177926f8423b5bbc03b5254">rlSetLowPowerModeConfig</a></li>
</ul>
<h2>Initialization and Calibration</h2>
<p>After initial static configurations, application should initialize RF and shall wait for calibration complete Asynchornous event RL_RF_AE_INITCALIBSTATUS_SB</p><ul>
<li><a class="el" href="group___sensor.html#ga958481166a629f374684c680904d5146">rlRfInit</a></li>
</ul>
<h2>FMCW chirp Configuration</h2>
<p>After RF initilization, Application can configure chirps and frame using below APIs</p><ul>
<li>Profile Configuration - <a class="el" href="group___sensor.html#gaadd84f565083150a4c09b28f77cf4294">rlSetProfileConfig</a></li>
<li>Chirp Configuraiton - <a class="el" href="group___sensor.html#ga02aca718122731c4376e25eeefe6ed5e">rlSetChirpConfig</a></li>
<li><p class="startli">Frame Configuration - <a class="el" href="group___sensor.html#gaf1e5cbc25891714db321da3bfa0d2014">rlSetFrameConfig</a> or rlSetAdvFrameConfig Note about HW SYNC_IN pulse in hardware triggered mode</p>
<p class="startli">a. The SYNC_IN pulse must not arrive before the frame end boundary b. If frame trigger delay is used with hardware triggered mode, then external SYNC_IN pulse periodicity should take care of the configured frame trigger delay and frame periodicity. The external pulse should be issued only after the sum total of frame trigger delay and frame periodicity. See figure below </p><div class="image">
<img src="mmwave_hwsyncincareabout.png" alt="mmwave_hwsyncincareabout.png"/>
</div>
<p> c. The inter frame blank time should be at least 250 uS(100 uS for frame preparation and 150 uS for any calibration updates to hardware). Add 150 uS to inter-frame blank time for test source configuration if test source is enabled.</p>
</li>
</ul>
<h2>Frame Trigger</h2>
<p>After All the configuration, Application can use Sensor Start API to start Frame and shall wait for Frame Ready Asynchronous event RL_RF_AE_FRAME_TRIGGER_RDY_SB</p><ul>
<li><a class="el" href="group___sensor.html#ga4ce3a292815faac84048977ad29658cd">rlSensorStart</a></li>
</ul>
<h2>Below is the list of advance features in mmWave Front end</h2>
<h2>Advance Frame</h2>
<p>Legacy frame config API <a class="el" href="group___sensor.html#gaf1e5cbc25891714db321da3bfa0d2014">rlSetFrameConfig</a> supports looping of the same FMCW frame. In order to configure multiple FMCW frames with different chirp profiles, user needs to use <a class="el" href="group___sensor.html#ga260d9e27b7b75c3cd33266a16f197ce7">rlSetAdvFrameConfig</a> API. Advance Frame consists of one or upto 4 Sub-Frames Each Sub-Frame consists of multiple bursts. Each burst consists of multiple chirps as shown in diagram below.<br />
 To enable Advance Frame, Application needs to follow below sequence</p><ul>
<li>Profile Configuration - <a class="el" href="group___sensor.html#gaadd84f565083150a4c09b28f77cf4294">rlSetProfileConfig</a></li>
<li>Chirp Configuraiton - <a class="el" href="group___sensor.html#ga02aca718122731c4376e25eeefe6ed5e">rlSetChirpConfig</a></li>
<li>Advance Frame Configuration - <a class="el" href="group___sensor.html#ga260d9e27b7b75c3cd33266a16f197ce7">rlSetAdvFrameConfig</a></li>
</ul>
<div class="image">
<img src="adv_frame_seq.png" alt="adv_frame_seq.png"/>
</div>
<h2>Dynamic Chirp Configuration</h2>
<p>Using Legacy chirp configuration API <a class="el" href="group___sensor.html#ga02aca718122731c4376e25eeefe6ed5e">rlSetChirpConfig</a>, chirps can't be re-configure without stopping the ongoing FMCW frame using <a class="el" href="group___sensor.html#ga3ed5478211ce88b74498e7978e200986">rlSensorStop</a> API. <br />
 If user needs to re-configure chirp during the frame, it needs to use Dynamic chirp config APIs. Once the API is received by mmWave Front end, it would re-configure the chirps for next FMCW frame. Dynamic Chirps can be defined using below APIs</p><ul>
<li>Dynamic Chirp Configuration - <a class="el" href="group___sensor.html#ga894bc8ce4536062a05aac4248334c964">rlSetDynChirpCfg</a></li>
<li>Enable Dynamic Chirps - <a class="el" href="group___sensor.html#gac24c37a764127e473cfa9c81320b31e9">rlSetDynChirpEn</a></li>
</ul>
<p>Diagram below shows the Dynamic Chirp behaviour. Note that since dynamic chirps are configured at run time, there is not error checks done on the input data. If input data is out of range or invalid, device might misbehave.</p>
<div class="image">
<img src="dyn_chip_seq.png" alt="dyn_chip_seq.png"/>
</div>
<h2>Calibration</h2>
<p>TI mmWave Front end includes built-in processor that is programmed by TI to handle RF calibrations and functional safety monitoring. The RF calibrations ensure that the performance of the device is maintained across temperature and process corners</p>
<ol type="1">
<li>Some of the calibrations are just temperature and process based look-up-tables, which are used to update the RF/Analog components</li>
<li>Built-in temperature sensors enable the device to monitor the temperature every few seconds and update the relevant components accordingly</li>
</ol>
<p>Below is the list of calibrations and corresponding duration in microseconds <br />
 Boot Time Calibration </p><a class="anchor" id="bootTimeCalibration"></a>
<table class="doxtable">
<caption>Calibration Duration</caption>
<tr>
<th>Calibration </th><th>Duration(us) </th></tr>
<tr>
<td>APLL</td><td>330 </td></tr>
<tr>
<td>Synth VCO</td><td>2500 </td></tr>
<tr>
<td>LO DIST</td><td>800 </td></tr>
<tr>
<td>ADC DC </td><td>600 </td></tr>
<tr>
<td>HPF cutoff </td><td>3500 </td></tr>
<tr>
<td>LPF cut off </td><td>200 </td></tr>
<tr>
<td>Peak detector</td><td>7000 </td></tr>
<tr>
<td>TX power (for each TX)</td><td>2000 </td></tr>
<tr>
<td>RX gain </td><td>1500 </td></tr>
<tr>
<td>TX phase (for each TX)</td><td>12000 </td></tr>
<tr>
<td>RX IQMM</td><td>42000 </td></tr>
</table>
<p>Run Time Calibration </p><a class="anchor" id="runTimeCalibration"></a>
<table class="doxtable">
<caption>Calibration Duration</caption>
<tr>
<th>Calibration </th><th>Duration(us) </th></tr>
<tr>
<td>APLL</td><td>150 </td></tr>
<tr>
<td>Synth VCO</td><td>350 </td></tr>
<tr>
<td>LO DIST</td><td>30 </td></tr>
<tr>
<td>Peak detector</td><td>600 </td></tr>
<tr>
<td>TX power CLPC (for each TX and for 1 profile)</td><td>800 </td></tr>
<tr>
<td>TX power OLPC (In case CLPC is disabled)</td><td>30 </td></tr>
<tr>
<td>RX gain </td><td>30 </td></tr>
<tr>
<td>Application of calibration to hardware (This needs to be included always) </td><td>100 </td></tr>
</table>
<h2>Chirp, Burst and Frame timings</h2>
<p>AWR2243 and xWR6843 device minimum chirp cycle time, inter-burst time, inter sub-frame/frame time requirements are documented in this section.</p>
<p>Chirp Cycle Time </p><a class="anchor" id="chirpCycleTime"></a>
<table class="doxtable">
<caption>Minimum chirp cycle time</caption>
<tr>
<th>Use case </th><th>Min Chirp cycle time(us)</th><th>Description </th></tr>
<tr>
<td>Typical chirps</td><td>13</td><td>The normal chirps used in a burst or a frame using legacy chirp configuration API </td></tr>
<tr>
<td>Advance chirps</td><td>25</td><td>The advance chirps used in a burst or a frame using advanced chirp configuration API </td></tr>
<tr>
<td>Advance chirp (Continuous framing mode)</td><td>30</td><td>A single advance chirp used in a burst using advanced chirp configuration API. Continuous framing mode is a mode in which a single chirp is programmed in a burst using advanced frame configuration API. </td></tr>
</table>
<p>Minimum Inter Burst Time </p><a class="anchor" id="interBurstTime"></a>
<table class="doxtable">
<caption>Minimum Inter Burst Time</caption>
<tr>
<th>Min inter burst time </th><th>Time(us)</th><th>Description </th></tr>
<tr>
<td>Typical inter burst time</td><td>55</td><td>The minimum inter burst idle time required in normal bursts with legacy chirps configured in a advanced frame configuration API with inter burst power save disabled. </td></tr>
<tr>
<td>Inter burst power save time</td><td>55</td><td>Add inter burst power save time to minimum inter burst time if it is enabled. By default inter-burst power save is enabled, it can be disabled using <a class="el" href="group___sensor.html#ga25ff76b7e26d26a184fd1c778cb4bf2f">rlRfSetDeviceCfg</a> API </td></tr>
<tr>
<td>Inter chirp power save override time (power save disable)</td><td>15</td><td>Add inter chirp power save override time to minimum inter burst time if chirp idle time &lt; 10us in a burst or can be controlled using <a class="el" href="group___sensor.html#ga6fa427b370b330f4c559793d2df92691">rlRfDynamicPowerSave</a> API </td></tr>
<tr>
<td>Advance chirp configuration time</td><td>45</td><td>Add advance chirp configuration time to minimum inter burst time if advance chirp configuration is enabled in <a class="el" href="group___sensor.html#ga8c3ef75c1d3da0a4134f6929107930e8">rlRfSetMiscConfig</a> API </td></tr>
<tr>
<td>Advance chirp configuration time (Continuous framing mode)</td><td>20</td><td>Add Continuous framing mode advance chirp configuration time to minimum inter burst time if advance chirp configuration is enabled in <a class="el" href="group___sensor.html#ga8c3ef75c1d3da0a4134f6929107930e8">rlRfSetMiscConfig</a> API. Continuous framing mode is a mode in which a single chirp is programmed in a burst using advanced frame configuration API. </td></tr>
<tr>
<td>Calibration or Monitoring chirp time</td><td>145</td><td>Add calibration or Monitoring chirp time to minimum inter burst time if calibration or monitors intended to be run in inter burst idle time. The calibration and monitoring chirps can run only in inter sub-frame or inter-frame interval if this time is not allocated in inter-burst time. Add calibration or Monitoring duration to minimum inter burst or sub-frame/frame time. </td></tr>
</table>
<p>Minimum Inter Sub-frame or Frame Time </p><a class="anchor" id="interSubFrameTime"></a>
<table class="doxtable">
<caption>Minimum Inter Sub-frame or Frame Time</caption>
<tr>
<th>Min inter subframe/frame time</th><th>Time(us)</th><th>Description </th></tr>
<tr>
<td>Typical inter subframe/frame time</td><td>300</td><td>The minimum inter sub-frame/frame idle time required in normal sub-frames with legacy chirps configured in a advanced frame configuration API or in a legacy frame config API. This time includes time required for minimum inter-burst idle time, inter burst power save, inter chirp power save override and single calibration/monitoring chirp time. </td></tr>
<tr>
<td>Advance chirp configuration time</td><td>45</td><td>Add advance chirp configuration time to minimum inter sub-frame/frame time if advance chirp configuration is enabled in <a class="el" href="group___sensor.html#ga8c3ef75c1d3da0a4134f6929107930e8">rlRfSetMiscConfig</a> API </td></tr>
<tr>
<td>Calibration or Monitoring duration</td><td>Table 12.4 and Table 12.8</td><td>Add calibration or Monitoring duration to minimum inter sub-frame/frame time based on Table 12.4 and Table 12.8 </td></tr>
<tr>
<td>Loop-back burst configuration time</td><td>300</td><td>Add Loop-back burst configuration time to minimum inter sub-frame time for loop back sub-frames if it is enabled in advance frame config API </td></tr>
<tr>
<td>Dynamic legacy chirp configuration time (for 16 chirps)</td><td>20</td><td>Add dynamic legacy chirp configuration time to minimum inter frame time if dynamic chirp/phase-shifter APIs are issued in runtime </td></tr>
<tr>
<td>Dynamic advance chirp configuration time (without LUT)</td><td>20</td><td>Add dynamic advance chirp configuration time to minimum inter frame time if dynamic advance chirp API is issued in runtime. The dynamic update of advance chirp generic LUT is done immediately when the API is received at BSS and there is no impact to inter frame time, however user has to take care of timing of the LUT update as it should not corrupt the ongoing chirp configuration. </td></tr>
<tr>
<td>Dynamic profile configuration time (for 1 profile)</td><td>700</td><td>Add dynamic profile configuration time to minimum inter frame time if dynamic profile API is issued in runtime. </td></tr>
</table>
<p>Typical APLL and Synth BW settings </p><a class="anchor" id="ApllSynthBwSettings"></a>
<table class="doxtable">
<caption>Typical APLL and Synth BW settings</caption>
<tr>
<th>SYNTH_ICP_TRIM</th><th>SYNTH_RZ_TRIM</th><th>APLL_ICP_TRIM</th><th>APLL_RZ_TRIM</th><th>VCO1_BW</th><th>VCO2_BW </th><th>APLL_BW</th><th>Description</th><th>Max VCO Slope (MHz/us) </th></tr>
<tr>
<td>1</td><td>8</td><td>0x26</td><td>0x9</td><td>750K</td><td>1.5M</td><td>150K</td><td>Default settings (+/-0.2% Ferror at 2us ADC start)</td><td>266 </td></tr>
<tr>
<td>3</td><td>8</td><td>0x26</td><td>0x9</td><td>375K</td><td>750K</td><td>150K</td><td>Optimum for 76-77GHz VCO1 (1M, 10M PN) </td><td>100 </td></tr>
<tr>
<td>0</td><td>8</td><td>0x26</td><td>0x9</td><td>1.3M</td><td>2.6M</td><td>150K</td><td>Synth High BW (+/-0.2% Ferror at 1us ADC start)</td><td>266 </td></tr>
<tr>
<td>3</td><td>8</td><td>0x3F</td><td>0x9</td><td>375K</td><td>1.5M</td><td>300K</td><td>Optimum 100K PN</td><td>100 </td></tr>
</table>
<p>Programmable filter DFE sampling rate and number of taps </p><a class="anchor" id="ProgFiltSettings"></a>
<table class="doxtable">
<caption>Programmable filter DFE sampling rate and number of taps</caption>
<tr>
<th>DFE sampling rate Fs (Msps)</th><th>No of taps in Real Mode</th><th>No of taps in Complex Mode </th></tr>
<tr>
<td>&gt;=25</td><td>42</td><td>NA </td></tr>
<tr>
<td>&gt;=12.5, &lt;25</td><td>42</td><td>21 </td></tr>
<tr>
<td>&gt;=6.25, &lt;12.5</td><td>63</td><td>45 </td></tr>
<tr>
<td>Else</td><td>63</td><td>63 </td></tr>
</table>
<pre class="fragment"> Related Files
- rl_sensor.c
</pre> <h2 class="groupheader">Function Documentation</h2>
<a id="ga65ff62ce5e024634fdc18df53dedf502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65ff62ce5e024634fdc18df53dedf502">&#9670;&nbsp;</a></span>rlEnableContMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlEnableContMode </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_cont_mode_en__t.html">rlContModeEn_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable Continous mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Continous Mode enable/disable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function enables/disables the FMCW radar continous mode </p>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l01336">1336</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga065915b702d27bda849435010af80a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga065915b702d27bda849435010af80a97">&#9670;&nbsp;</a></span>rlFrameStartStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlFrameStartStop </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_frame_trigger__t.html">rlFrameTrigger_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triggers/Stops Transmission of Frames. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Container for Frame trigger Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function triggers/stops the transmission of the frames as per the frame and chirp configuration. If trigger mode is selected as SW API based trigger, mmWaveFront end would start chirp immediately after receiving this API. If trigger mode is HW SYNC IN pulse, it would wait for SYNC pulse</p>
<dl class="section note"><dt>Note</dt><dd>1: Once the chirping starts, mmWave Front end would send asynchronous event RL_RF_AE_FRAME_TRIGGER_RDY_SB indicating the start of frame </dd>
<dd>
2: Once the chirping stops, mmWave Front end would send asynchronous event RL_RF_AE_FRAME_END_SB indicating the stop of frame </dd>
<dd>
3: When Frame Stop command with 'option-0' is sent to RadarSS, the frame will be stopped after completing all the chirps of a Frame/Advance frame (sub-frames). <br />
</dd>
<dd>
4: In non periodic Hw triggered mode or in sub-frame triggered mode, if frame needs to be stopped immediately then frame stop command with 'option-4' can be used. The 'option-4' can not be used when active frames are running. <br />
</dd>
<dd>
5: Recommended to re-issue frame configuration API if frame is not stopped at sub-frame boundary, this is to re-config CSI2 or LVDS data path configuration in MSS. <br />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l01536">1536</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga12e48d543221c5e1312a6bb73d209ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12e48d543221c5e1312a6bb73d209ffe">&#9670;&nbsp;</a></span>rlGetAdvFrameConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlGetAdvFrameConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_adv_frame_cfg__t.html">rlAdvFrameCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets Advance Frame Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>- Container for Advance Frame Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function reads the advance frame properties of the device. This API calls internally two APIs, one to RadraSS for sensor configuraion and another to MasterSS for datapath configuraion. <br />
</p>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l01225">1225</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="gaf441aded0e05ef3139df6b1fe2a607ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf441aded0e05ef3139df6b1fe2a607ed">&#9670;&nbsp;</a></span>rlGetChirpConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlGetChirpConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rlUInt16_t&#160;</td>
          <td class="paramname"><em>chirpStartIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rlUInt16_t&#160;</td>
          <td class="paramname"><em>chirpEndIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_chirp_cfg__t.html">rlChirpCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets Chirp Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chirpStartIdx</td><td>- Chirp Start Index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chirpEndIdx</td><td>- Chirp End Index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>- Container for Chirp Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function gets the chirp configuration from the device. </p>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l00713">713</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga7619b9244bcee4f602cf3f4f995394c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7619b9244bcee4f602cf3f4f995394c8">&#9670;&nbsp;</a></span>rlGetFrameConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlGetFrameConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_frame_cfg__t.html">rlFrameCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets Frame Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>- Container for Frame Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function reads the frame properties of the device. This API calls internally two APIs, one to RadraSS for sensor configuraion and another to MasterSS for datapath configuraion. <br />
</p>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l01067">1067</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga52dfab9a128a66d75e51bf4d741a424b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52dfab9a128a66d75e51bf4d741a424b">&#9670;&nbsp;</a></span>rlGetProfileConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlGetProfileConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rlUInt16_t&#160;</td>
          <td class="paramname"><em>profileId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_profile_cfg__t.html">rlProfileCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets Chirp profile Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">profileId</td><td>- Profile Id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>- Container for Profile Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function gets the FMCW radar chirp properties like FMCW slope, chirp duration, TX power etc. from the device. </p>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l00515">515</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga67c4baf29d7b1cfb475052cf9a432b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67c4baf29d7b1cfb475052cf9a432b83">&#9670;&nbsp;</a></span>rlGetRfBootupStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlGetRfBootupStatus </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_boot_status_cfg__t.html">rlRfBootStatusCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get radarSS bootup status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- bootup status configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API gets the radarSS bootup status </p>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l03338">3338</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga333b50fae881b6e9de6700be35e3836e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga333b50fae881b6e9de6700be35e3836e">&#9670;&nbsp;</a></span>rlGetRfDieId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlGetRfDieId </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_die_id_cfg__t.html">rlRfDieIdCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get device die ID status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>- Die ID status</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API gets the device Die ID status </p>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l03618">3618</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga7db78d5d4c9f0af5100ce685eb0675db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7db78d5d4c9f0af5100ce685eb0675db">&#9670;&nbsp;</a></span>rlMonTypeTrigConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlMonTypeTrigConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_mon_type_trig_cfg__t.html">rlMonTypeTrigCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maintains monitoring timing synchronization in cascaded devices to avoid mutual interference of monitors running in different devices in the cascade sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- structure contains monitor trigger type configs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API helps to maintain monitoring timing synchronization in cascaded devices to avoid mutual interference of monitors running in different devices in the cascade sensor. <br />
The host must trigger the monitor of types below to avoid interference if MONITORING MODE is set to ’1’ in AWR_CALIB_MON_TIME_UNIT_CONF_SB. <br />
 The AWR_AE_RF_MONITOR_TYPE_TRIGGER_DONE_SB_AE will be sent once monitor type is executed <br />
The monitors can be categorized into 3 types : <br />
 Monitor Types Description Type 0 Non-transmitting monitor, The execution of non-transmitting monitors does not cause RF interference to monitors executing on other devices. Therefore, they can be executed in parallel across all devices in the cascade. These include monitors which receive a test signal through RX LNA and digital monitors. <br />
 Type 1 Transmitting but not receiving (test signal), The monitors that transmit but don’t receive any test signal through RX LNA are not susceptible to interference. Therefore, they can be executed in parallel across all devices in the cascade, but not when monitors that receive test signals through RX LNA are executing. <br />
 Type 2 Transmitting and receiving (test signal), The monitors that transmit and also receive test signal through RX LNA are susceptible to interference. They can be executed sequentially so as to create time separation between monitoring chirps of different devices <br />
 </p><dl class="section note"><dt>Note</dt><dd>1: This is a new feature addition in AWR2243. <br />
</dd>
<dd>
2: The Host can trigger all 3 types of monitor at same time or can trigger each type one after other based on system requirement, in case host is triggering monitor types one after other, then it is recommended to follow order type 0, type 1 and type 2 respectively. <br />
</dd>
<dd>
3: The Host must wait for AWR_AE_RF_MONITOR_TYPE_TRIGGER_DONE_SB_AE before issuing trigger for next monitor type. <br />
</dd>
<dd>
4: The Host must ensure all types of monitors are executed within defined device FTTI interval, otherwise device can not finish all the monitors within FTTI and will report failure AE_AWR_CAL_MON_TIMING_FAIL_REPORT_AE_SB <br />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l03864">3864</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="gaba5f6d1fc69ec1cf5769351a10996bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba5f6d1fc69ec1cf5769351a10996bfc">&#9670;&nbsp;</a></span>rlRfApllSynthBwCtlConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfApllSynthBwCtlConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_apll_synth_bw_control__t.html">rlRfApllSynthBwControl_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control bandwidth of the APLL and Synthesizer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- APLL and Synthesizer B/W control data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API is used to control bandwidth of the APLL and Synthesizer</p>
<dl class="section note"><dt>Note</dt><dd>1 : This API is supported only in AWR2243. <br />
</dd>
<dd>
2 : Recommended to issue this API before <a class="el" href="group___sensor.html#ga958481166a629f374684c680904d5146">rlRfInit</a> API. The RF_INIT synthesizer boot calibration shall run after changing the APLL BW. <br />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l03908">3908</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga0f501504c14a199cb1c9a7073e545acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f501504c14a199cb1c9a7073e545acd">&#9670;&nbsp;</a></span>rlRfCalibDataRestore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfCalibDataRestore </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_calibration_data__t.html">rlCalibrationData_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Injects calibration data to the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Calibration data of 3 chunks stored at application space</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API restores the calibration data which was stored previously using the rlCalibDataStore command. Application needs to feed in 3 chunks of calibration data. recommended API sequence for calibration data restore is: <br />
</p><ol type="1">
<li>rlRfCalibDataRestore (To restore factory calibration data to avoid on field RF interference during calibration) <br />
</li>
<li>Wait for RL_RF_AE_INITCALIBSTATUS_SB event. <br />
</li>
<li>rlRfInitCalibConfig (Enable only required calibration to run) <br />
</li>
<li>rlRfInit: This triggers very basic calibrations and RF initializations. <br />
</li>
<li>Wait for RL_RF_AE_INITCALIBSTATUS_SB event. <br />
 <dl class="section note"><dt>Note</dt><dd>1: Once the calibration data is restored properly in radarSS SW RAM and validated, mmWave Front end would send asynchronous event RL_RF_AE_INITCALIBSTATUS_SB indicating the result of the calibrations based on Calib data sent by the application, this indicates success of the calibration data restore. </dd>
<dd>
2: All 3 chunks of 224 bytes each shall be sent to radar device to complete the restore process and to generate RL_RF_AE_INITCALIBSTATUS_SB. </dd></dl>
</li>
</ol>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l03143">3143</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="gaed333a050ab0ff53b5ab5a808e715a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed333a050ab0ff53b5ab5a808e715a5c">&#9670;&nbsp;</a></span>rlRfCalibDataStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfCalibDataStore </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_calibration_data__t.html">rlCalibrationData_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read calibration data from the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Calibration data of 3 chunks which will filled by device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API reads the calibration data from the device which can be injected later using the rlCalibDataRestore command. RadarSS will return 3 chunks of calibration data.</p>
<dl class="section note"><dt>Note</dt><dd>1: The total size of the calibration data is 672 bytes, this has been split into 3 chunks (numOfChunk)of 224 bytes each due to SPI limitation. The Host should receive all these 3 chunks from radar device, later host can store only relevant data in non volatile memory. </dd>
<dd>
2: Before storing the calibration data in non volatile memory, the host shall make sure validity status of all enabled calibrations are SET to value 1 including APLL, VCO1, VCO2 and LODIST calibration validity in rlRfInit of radar device. </dd>
<dd>
3: Host can store only relevant calibration data in non volatile memory and corresponding validity bits shall be set to 1 in rlRfCalibDataRestore and rest of the validity bits should be clear to 0 before restoring the data to radar device. </dd>
<dd>
4: Host shall ignore APLL, VCO1, VCO2 and LODIST calibration validity bits while restoring, these calibrations will be done in each device power-up. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l03224">3224</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga39cf05329fbbf5783f53d8f80644e3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39cf05329fbbf5783f53d8f80644e3ff">&#9670;&nbsp;</a></span>rlRfDfeRxStatisticsReport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfDfeRxStatisticsReport </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_dfe_stat_report__t.html">rlDfeStatReport_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets Digital Front end statistics such as Residual DC, RMS power in I and Q chains for different Receive channels for different selected profiles. It also includes Cross correlation between I and Q chains. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Container of dfe receiver status report</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>Gets Digital Front end statistics such as Residual DC, RMS power in I and Q chains for different Receive channels for different selected profiles. It also includes Cross correlation between I and Q chains </p>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l01756">1756</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga6fa427b370b330f4c559793d2df92691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fa427b370b330f4c559793d2df92691">&#9670;&nbsp;</a></span>rlRfDynamicPowerSave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfDynamicPowerSave </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_dyn_pwr_save__t.html">rlDynPwrSave_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: Configure dynamic power saving feature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Container of dynamic power save information</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>Configure dynamic power saving feature during Inter chirp Idle time by turning off various circuits such as Transmitter, Receiver and LO distribution blocks </p><dl class="section note"><dt>Note</dt><dd>1: whether to enable dynamic power saving during inter-chirp IDLE times by turning off various circuits e.g. TX, RX, LO Distribution blocks. If Idle time + Tx start time &lt; 10us or Idle time &lt; 3.5us then inter-chirp dynamic power save option will be disabled, in that case, 15us of inter-burst idle time will be utilized to configure sequencer LO, TX and RX signal timings by firmware. </dd>
<dd>
2: All the 3 configuration bits (TX, RX and LO) should have same value, i.e. user should program value 0x7 to enable power save or 0x0 to disable the power save in blkCfg. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l01804">1804</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga54ab920ef9fb4e46657d774ef491cb9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54ab920ef9fb4e46657d774ef491cb9d">&#9670;&nbsp;</a></span>rlRfGetCpuFault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfGetCpuFault </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_cpu_fault__t.html">rlCpuFault_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get RadarSS CPU fault status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Container for RadarSS CPU fault status</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API gets the RadarSS CPU fault status. </p>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l03650">3650</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga5eeb5e099b9e310c7b1f5aae27289822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5eeb5e099b9e310c7b1f5aae27289822">&#9670;&nbsp;</a></span>rlRfGetEsmFault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfGetEsmFault </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_bss_esm_fault__t.html">rlBssEsmFault_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get RadarSS ESM fault status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Container for RadarSS ESM fault status</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API gets the RadarSS ESM fault status. </p>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l03688">3688</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga335113f6e1e6c260dcd03e03a0932a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga335113f6e1e6c260dcd03e03a0932a1b">&#9670;&nbsp;</a></span>rlRfGetTemperatureReport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfGetTemperatureReport </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_temp_data__t.html">rlRfTempData_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets Time and Temperature information report. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>- Structure to store temperature report from all the temp sensors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function reads Temperature information from all temperature sensors in the device </p>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l01715">1715</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga958481166a629f374684c680904d5146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga958481166a629f374684c680904d5146">&#9670;&nbsp;</a></span>rlRfInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfInit </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the RF/Analog Subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>Initializes the RF/Analog Subsystem. This triggers one time calibrations for APLL and synthesizer. Calibration can be enabled/disabled using Calibraton configuration APIs. Device will turn on Tx/Rx and components for the calibration which will cause higher curent consumption momenterily.</p>
<dl class="section note"><dt>Note</dt><dd>1: Once the calibration is complete, mmWave Front end would send asynchronous event RL_RF_AE_INITCALIBSTATUS_SB indicating the result of the initialization/calibrations. Application needs to wait for this Async event message before calling next APIs. </dd>
<dd>
2: The following boot-time calibrations are susceptible to corruption by interference. The calibrations may result in false configuration of the RF analog sections due to corruption by interference during the calibration measurements. <br />
 a. RX gain calibration (susceptible to interference) <br />
 b. RX IQMM calibration (susceptible to interference) <br />
 c. TX Phase calibration (susceptible to interference) <br />
 It is recommended to perform factory calibration and store the calibration data in non volatile memory using rlRfCalibDataStore. This data can be restored to radar device using rlRfCalibDataRestore API. <br />
</dd>
<dd>
3: It is not recommended to issue this API in runtime multiple times. This API shall be issued only once after power cycle with or without calibration data restore operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l01591">1591</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="gabc0c70e4c766a79ec281f969d0c61561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc0c70e4c766a79ec281f969d0c61561">&#9670;&nbsp;</a></span>rlRfInitCalibConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfInitCalibConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_init_cal_conf__t.html">rlRfInitCalConf_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set RF Init Calibration Mask bits and report type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- RF Init calib config</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function configures RF Init calibration mask bits and report type. Normally, upon receiving rlRfInit API, the Radar SS performs all relevant initial calibrations. This step can be disabled by setting the corresponding bit in <a class="el" href="structrl_rf_init_cal_conf__t.html">rlRfInitCalConf_t</a> field to 0x0.If disabled, the host needs to send the calibration data using <a class="el" href="group___sensor.html#ga0f501504c14a199cb1c9a7073e545acd">rlRfCalibDataRestore</a> so that the RadarSS can operate using the injected calibration data</p>
<dl class="section note"><dt>Note</dt><dd>1 : Each of these calibrations can be selectively disabled by issuing this message before rlRfInit API. </dd>
<dd>
2 : The APLL, SYNTH1 and SYNTH2 calibrations are always triggred by default on RF init command. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l02474">2474</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga401d0fb21dcf7d34bea938b2cd74e5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga401d0fb21dcf7d34bea938b2cd74e5ba">&#9670;&nbsp;</a></span>rlRfInterRxGainPhaseConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfInterRxGainPhaseConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_inter_rx_gain_ph_conf__t.html">rlInterRxGainPhConf_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets different Rx gain/phase offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Inter RX gain, phase offset config</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API can be used to compensate various RX and gain/phase offsets and same API can be used to estimation the same using TX frequency shift.</p>
<dl class="section note"><dt>Note</dt><dd>1: This API is supported only on AWR2243 device. Please refer latest DFP release note for more info. <br />
</dd>
<dd>
2: Issue this API first in the sequence before <a class="el" href="group___sensor.html#gaadd84f565083150a4c09b28f77cf4294">rlSetProfileConfig</a> API. </dd>
<dd>
3: The Digital TX frequency shift enable mode in below API is for debug purpose only, the functional phase shifter will not be operational when this mode is used. It is recommended to re-issue profile config API after disabling this mode before running functional frames. <br />
</dd>
<dd>
4: An application for the digital delay compensation field may be to digitally compensate for linear IF frequency dependent phase mismatch (e.g. mismatch across devices in cascaded operation, caused by DIG_SYNC_IN path mismatches). The residual phase error can be up to +/-0.5 degree. <br />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l03305">3305</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga8983749694adc19bcc2fdf9144cfa0a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8983749694adc19bcc2fdf9144cfa0a4">&#9670;&nbsp;</a></span>rlRfPhShiftCalibDataRestore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfPhShiftCalibDataRestore </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_ph_shift_calibration_data__t.html">rlPhShiftCalibrationData_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Injects phase shifter calibration data to the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Calibration data of number of TX channels enabled chunks stored at application space</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API restores the phase shifter calibration data which was stored previously using the rlRfPhShiftCalibDataStore command. Application needs to feed number of TX channels enabled chunks of phase shifter calibration data. This is device specific feature, please refer data sheet. </p>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l03469">3469</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga00f3f0bee9ac7b8f6e35b8df1658158d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00f3f0bee9ac7b8f6e35b8df1658158d">&#9670;&nbsp;</a></span>rlRfPhShiftCalibDataStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfPhShiftCalibDataStore </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_ph_shift_calibration_data__t.html">rlPhShiftCalibrationData_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read calibration data from the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Phase shift calibration data of number of TX channels enbled chunks which will filled by device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API reads the phase shifter calibration data from the device which can be injected later using the rlRfPhShifterCalibDataRestore command. RadarSS will return number of TX chunks of phase shifter calibration data.This is device specific feature, please refer data sheet. </p>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l03544">3544</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="gab47b62709a01f0ba5bdcf3f804dd5a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab47b62709a01f0ba5bdcf3f804dd5a1a">&#9670;&nbsp;</a></span>rlRfRunTimeCalibConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfRunTimeCalibConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_run_time_calib_conf__t.html">rlRunTimeCalibConf_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set RF one time &amp; periodic calibration of various RF/analog aspects and trigger. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Runtime calibration config</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function configures RF one time &amp; periodic calibration of various RF/analog aspects and trigger. The response is in the form of an asynchronous event. The calibration would be performed by Radar SS during while framing during inter-burst idle time slot of 250uS.</p>
<dl class="section note"><dt>Note</dt><dd>1: This API must be called after rlSetProfileConfig </dd>
<dd>
2: This API should be issued when the device is not framing. </dd>
<dd>
3: This API can be issued when the device is framing, the calibration periodicity update or one time calibrations can be done while frames are running. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l02518">2518</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga012ff7b3e35f35373169b62e4227ce06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga012ff7b3e35f35373169b62e4227ce06">&#9670;&nbsp;</a></span>rlRfSetCalMonFreqLimitConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfSetCalMonFreqLimitConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_cal_mon_freq_limit_conf__t.html">rlRfCalMonFreqLimitConf_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Calibration monitoring Frequency Limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- RF Calib Frequency Limit config</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function configures limits on RF frequency transmission during calibration and monitoring</p>
<dl class="section note"><dt>Note</dt><dd>1 : The minimum RF bandwidth shall be set to 200MHz, this is to perform internal calibration and monitoring <br />
</dd>
<dd>
2 : The limit set in this API is not applicable for functional chirps and loop-back chirps used in advanced frame config API. <br />
</dd>
<dd>
3 : The TX0 frequency limit is used by default in calibrations and monitors where TX is not relevant or enabled. <br />
</dd>
<dd>
4 : The RF band used in functional chirp profiles shall be within the limit set in this API. <br />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l02427">2427</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga0ff25a87cf2f34635bb469d3df1d48ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ff25a87cf2f34635bb469d3df1d48ed">&#9670;&nbsp;</a></span>rlRfSetCalMonTimeUnitConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfSetCalMonTimeUnitConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_cal_mon_time_unt_conf__t.html">rlRfCalMonTimeUntConf_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Calibration monitoring time unit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- RF Calib Monitoring Time unit config</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function configures calibration monitoring time unit</p>
<dl class="section note"><dt>Note</dt><dd>1: The Minimum total blank time in a calibMonTimeUnit shall be 1ms to run internal APLL and SYNTH calibrations + ~12.5% of calibMonTimeUnit for WDT clearing time if WDT is enabled. <br />
</dd>
<dd>
2: Refer to <a class="el" href="group___monitoring.html#AnalogMonitoringDuration">AnalogMonitoringDuration</a>, <a class="el" href="group___monitoring.html#DigitalMonitoringDuration">DigitalMonitoringDuration</a> for the duration of run time monitors and <a class="el" href="group___monitoring.html#SoftwareOverheads">SoftwareOverheads</a> for software overheads. </dd>
<dd>
3: The CALIB_MON_TIME_UNIT is applicable for one frame trigger API. Once frame is stopped then FTTI will reset, CALIB_MON_TIME_UNIT is not applicable across multiple SW frame trigger API. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l02377">2377</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga25ff76b7e26d26a184fd1c778cb4bf2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25ff76b7e26d26a184fd1c778cb4bf2f">&#9670;&nbsp;</a></span>rlRfSetDeviceCfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfSetDeviceCfg </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_dev_cfg__t.html">rlRfDevCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: Set different RadarSS device configurations </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Configuration parameter for AE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>Set different RadarSS device configurations. Enable and Configure asynchronous event direction for device. By default all asynchronous event are enabled and sent to the platform which issued the API. Below events can be configured to be received on different platform by using this API:<br />
[1.] CPU_FAULT [2.] ESM_FAULT [3.] ANALOG_FAULT Similarly all monitoring events can be configured to be received on specific platform using this API Below events can be disabled using this API:<br />
[1.] FRAME_START_ASYNC_EVENT [2.] FRAME_STOP_ASYNC_EVENT <br />
Enable[1]/Disable[0] RadarSS Watchdog, where by default it is disable. Configure CRC type for asynchronous event from RadarSS [0] 16Bit, [1] 32Bit, [2] 64Bit. </p>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l01853">1853</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="gafd9d2dcea706ab65fe6b949e2008c6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd9d2dcea706ab65fe6b949e2008c6ed">&#9670;&nbsp;</a></span>rlRfSetIFLoopbackConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfSetIFLoopbackConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_i_f_loopback_cfg__t.html">rlRfIFLoopbackCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable RF IF loopback for all enabled profiles. This is used for debug to check if both TX and RX chains are working correctly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- IF loopback configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function Enables/Disables RF IF loopback for all enabled profiles. This is used to debug the RX IF chain.</p>
<dl class="section note"><dt>Note</dt><dd>1: The IF loop-back configuration API is supported only for debug purpose. Please refer latest DFP release note for more info. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l02198">2198</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga8c3ef75c1d3da0a4134f6929107930e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c3ef75c1d3da0a4134f6929107930e8">&#9670;&nbsp;</a></span>rlRfSetMiscConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfSetMiscConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_misc_conf__t.html">rlRfMiscConf_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets misc feature such as per chirp phase shifter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Misc configuration such as per chirp phase shifter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function enables misc feature such as per chirp phase shifter.This API is valid for devices for which phase shifter is enabled(AWR1243P, AWR2243, AWR1843).</p>
<dl class="section note"><dt>Note</dt><dd>: Issue this API first in the sequence if <a class="el" href="group___sensor.html#gaf9450d508e0fa2857f8f9cb6b5004ecc">rlRfSetPhaseShiftConfig</a>, <a class="el" href="group___sensor.html#ga37cb66bac3ce58d418d45a9e0ad26e53">rlSetDynPerChirpPhShifterCfg</a> and <a class="el" href="group___sensor.html#ga3c1fe92af102850c9889e77437159a80">rlSetAdvChirpConfig</a> are issued down in the sequence. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l02330">2330</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga9e53c805ac1b08ec8939dfe3205fe359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e53c805ac1b08ec8939dfe3205fe359">&#9670;&nbsp;</a></span>rlRfSetPALoopbackConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfSetPALoopbackConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_p_a_loopback_cfg__t.html">rlRfPALoopbackCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable PA loopback for all enabled profiles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- PA loopback configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function Enables/Disables PA loopback for all enabled profiles. This is used for debug purpose that both the TX and RX paths are working properly</p>
<dl class="section note"><dt>Note</dt><dd>1: The PA loop-back configuration API is supported only for debug purpose. Please refer latest DFP release note for more info. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l02115">2115</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="gaf9450d508e0fa2857f8f9cb6b5004ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9450d508e0fa2857f8f9cb6b5004ecc">&#9670;&nbsp;</a></span>rlRfSetPhaseShiftConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfSetPhaseShiftConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rlUInt16_t&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_phase_shift_cfg__t.html">rlRfPhaseShiftCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable phase shift configurations per chirp in each of the TXs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cnt</td><td>- Number of configurations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- phase shift enable/disable configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function configures the static phase shift configurations per chirp in each of the TXs. This API is applicable only in certain devices (please refer data sheet). This API will be honored after enabling per chirp phase shifter in rlRfSetMiscConfig.</p>
<dl class="section note"><dt>Note</dt><dd>1: Phase shifter(PS) settings are applied in advance at max -5us or at -(idleTimeConst-1.28us-DfeLagTime) from the knee of the ramp. If idle time &gt; 6.28us, then PS is applied always at -5us and if idle time &lt; 6.28us, then PS is applied at -(idleTimeConst-1.28us-DfeLagTime) from knee of the ramp. Where DfeLagTime is internal DFE lag time (Please refer rampgen calculator). </dd>
<dd>
2: It is recommended to configure TX start time &gt; -5us or -(idleTimeConst-1.28us-DfeLagTime) based on PS apply time. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l01992">1992</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga76d9fa9dcd3af870a2bb46f6f1b5e8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76d9fa9dcd3af870a2bb46f6f1b5e8f2">&#9670;&nbsp;</a></span>rlRfSetProgFiltCoeffRam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfSetProgFiltCoeffRam </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_prog_filt_coeff__t.html">rlRfProgFiltCoeff_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Programmable Filter coefficient RAM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- array of coefficients for the programmable filter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function is used to program the coefficients for the external programmable filter. This is a new feature added in AWR2243.</p>
<dl class="section note"><dt>Note</dt><dd>1: The programmable filter allow for a trade-off between digital filter chain settling time and close-in anti-alias attenuation. The Maximum DFE outout sampling rate in real mode is 25Msps and in complex mode is 22.5Msps. <br />
 A real-coefficient FIR with up to 63 taps (16-bit coefficients) is supported in both Complex and real output mode. <br />
</dd>
<dd>
2: Please refer Table <a class="el" href="group___sensor.html#ProgFiltSettings">ProgFiltSettings</a> for details on Programmable filter DFE sampling rate and number of taps. <br />
</dd>
<dd>
3: This API should be issued before rlSetProfileConfig. <br />
</dd>
<dd>
4: This API should not be issued when frames are ongoing. <br />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l02246">2246</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga935fe658cc0e519559c6f705dfeb9297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga935fe658cc0e519559c6f705dfeb9297">&#9670;&nbsp;</a></span>rlRfSetProgFiltConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfSetProgFiltConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_prog_filt_conf__t.html">rlRfProgFiltConf_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Programmable Filter configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- programmable filter configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function selects programmable filter cofficient RAM and map it to configured profile ID.</p>
<dl class="section note"><dt>Note</dt><dd>1: This API is applicable only in xWR1642/xWR6843/xWR1843/AWR2243. </dd>
<dd>
2: This API should not be issued when frames are ongoing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l02288">2288</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga78dfcfa4b7fb299434d22edcedb4746d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78dfcfa4b7fb299434d22edcedb4746d">&#9670;&nbsp;</a></span>rlRfSetPSLoopbackConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfSetPSLoopbackConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_p_s_loopback_cfg__t.html">rlRfPSLoopbackCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable Phase shift loopback for all enabled profiles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Phase shift loopback configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function Enables/Disables Phase shift loopback for all enabled profiles.This is used to debug the TX (before the PA) and RX chains.</p>
<dl class="section note"><dt>Note</dt><dd>1: The PS loop-back configuration API is supported only for debug purpose. Please refer latest DFP release note for more info. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l02156">2156</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga938c6847f8a19336019883723c1e214c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga938c6847f8a19336019883723c1e214c">&#9670;&nbsp;</a></span>rlRfTxFreqPwrLimitConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfTxFreqPwrLimitConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_tx_freq_pwr_limit_mon_conf__t.html">rlRfTxFreqPwrLimitMonConf_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the limits for RF frequency transmission for each TX and also TX power limits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Tx Rf freq and power limit config data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API sets the limits for RF frequency transmission for each TX and also TX power limits.</p>
<dl class="section note"><dt>Note</dt><dd>1 : The minimum RF bandwidth shall be set to 200MHz, this is to perform internal calibration and monitoring <br />
</dd>
<dd>
2 : The limit set in this API is not applicable for functional chirps and loop-back chirps used in advanced frame config API. <br />
</dd>
<dd>
3 : The TX0 frequency limit is used by default in calibrations and monitors where TX is not relevant or enabled. <br />
</dd>
<dd>
4 : The RF band used in functional chirp profiles shall be within the limit set in this API. <br />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l02759">2759</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="gae35c3687d353c0fb6ad2a9cc08ccff3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae35c3687d353c0fb6ad2a9cc08ccff3c">&#9670;&nbsp;</a></span>rlRxGainTempLutSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRxGainTempLutSet </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rx_gain_temp_lut_data__t.html">rlRxGainTempLutData_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrite RX gain temperature Lookup Table(LUT) in Radar SS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- RX gain Temperature LUT config</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API can be used to overwrite the RX gain Lookup Table(LUT) for different temperature used in RadarSS.</p>
<dl class="section note"><dt>Note</dt><dd>1 : This API should be issued after profile configuration API. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l02558">2558</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga4ce3a292815faac84048977ad29658cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ce3a292815faac84048977ad29658cd">&#9670;&nbsp;</a></span>rlSensorStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSensorStart </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triggers Transmission of Frames. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function triggers the transmission of the frames as per the frame and chirp configuration If trigger mode is selected as SW API based trigger, mmWaveFront end would start chirp immediately after receiving this API. If trigger mode is HW SYNC IN pulse, it would wait for SYNC pulse</p>
<dl class="section note"><dt>Note</dt><dd>1: Once the chirping starts, mmWave Front end would send asynchronous event RL_RF_AE_FRAME_TRIGGER_RDY_SB indicating the start of frame </dd>
<dd>
2: This API might get deprecated in future releases. Refer to <a class="el" href="group___sensor.html#ga065915b702d27bda849435010af80a97">rlFrameStartStop</a> API </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l01424">1424</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga3ed5478211ce88b74498e7978e200986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ed5478211ce88b74498e7978e200986">&#9670;&nbsp;</a></span>rlSensorStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSensorStop </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops Transmission of Frames. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function stops the transmission of the frames.</p>
<dl class="section note"><dt>Note</dt><dd>1: Once the chirping stops, mmWave Front end would send asynchronous event RL_RF_AE_FRAME_END_SB indicating the stop of frame </dd>
<dd>
2: When Frame Stop command is sent to RadarSS, the frame will be stopped after completing all the chirps of a Frame/Advance frame. In non periodic HW triggered mode if frame stop command is issued when HW pulses are paused (i.e after completing previous frame) then a HW pulse is required to trigger next frame/bursts and frame will be stopped at the end of this triggered frame. In HW triggered mode, the forced frame stop is not supported, the frame end command is honored only if frames are actively running. </dd>
<dd>
3: This API might get deprecated in future releases. Refer to <a class="el" href="group___sensor.html#ga065915b702d27bda849435010af80a97">rlFrameStartStop</a> API </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l01477">1477</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="gadf97bc35cf7acd9035b0fcadb00f3ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf97bc35cf7acd9035b0fcadb00f3ad3">&#9670;&nbsp;</a></span>rlSetAdcOutConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetAdcOutConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_adc_out_cfg__t.html">rlAdcOutCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets ADC Output Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Container for ADC Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function sets the static device configuration for the data format of the ADC and digital front end output. This is RAW ADC samples of IF signal and needs to be processed by HW accelerator or DSP. The ADC data can be sent to external Processor over High Speed Interface such as LVDS or CSI2. The ADC data size supported are 12, 14 and 16 bits and supported formats are Real, Complex 1x and Complex 2x. In Complex 1x, Image band is filtered out and only signal band is sampled in ADC. Where as in Complex 2x, Both Image and Signal band is sampled.<br />
 Complex baseband architecture results in better noise figure and is recommended.</p>
<dl class="section note"><dt>Note</dt><dd>At the same sampling frequency(Fs), Complex 1x would support IF bandwidth of Fs, where as real and complex 2x would provide IF bandwidth of upto Fs/2. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l00151">151</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga3c1fe92af102850c9889e77437159a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c1fe92af102850c9889e77437159a80">&#9670;&nbsp;</a></span>rlSetAdvChirpConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetAdvChirpConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_adv_chirp_cfg__t.html">rlAdvChirpCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Advanced chirp configuration to the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- structure contains adv-chirp configs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API defines the programming of advanced chirp configurations for each chirp parameters to generate a waveform pattern in a frame/burst. It provides ability to program fixed delta increment (Delta dither) for certain chirp parameters (eg. chirp start frequency, idle time, phase shifter), on top of unique dithers selected from configurable look-up-table (LUT Dither). The configurable look-up-table is an array of values loaded into a pre-configured Generic SW Chirp Parameter LUT. The size of the generic LUT is 12kB and user has the flexibility to program any number of unique dithers for each chirp parameters. Thus the user can achieve fixed increment, or LUT based dither, or a combination of both. <br />
 When using the Advanced Chirp Config API, there are some implications to frame config and advanced frame config APIs. Specifically, the CHIRP_START_INDX and CHIRP_END_INDX fields are no longer applicable, and the NUM_LOOPS field has a different meaning in the sense that this field now denotes the total number of chirps in the frame/burst. Please refer AWR_FRAME_CONF_SET_SB and AWR_ADVANCED_FRAME_CONF_SB APIs with the updated field descriptions as below. <br />
 The total number of chirps L in a burst should be programmed as per below calculation in frame configuration API (using the NUM_LOOPS field). <br />
L = X * Y, where X is 1 to 512 (supported HW CHIRP RAM) and Y is 1 to 128 (supported HW CHIRP LOOPS) <br />
The value of L should be a multiple of 4 (assuming each chirp is min 25us duration) i.e 1, 4, 8, 12, 16, 20, 24 ¦ 32768 (max). The FW needs to prepare and update HW CHIRP RAM dynamically in advance chirp config API, this puts some restriction on minimum number of chirps in a burst/frame. <br />
 Using this API, four types of control can be achieved on each parameters of a chirp. <br />
</p><ol type="1">
<li>Fixed value for all chirps: To generate sequence of chirps which never changes, then only one value can be programmed in LUT (LUT Dither), i.e NUM_OF_PATTERNS (P) = 1 and LUT_PARAM_UPDATE_PERIOD (K) = 0 <br />
</li>
<li>Unique chirps: Index every LUT_PARAM_UPDATE_PERIOD (K) chirps in LUT to generate unique sequence of chirps. <br />
</li>
<li>Delta increment every DELTA_PARAM_UPDATE_PERIOD (N) chirps: On top of sequence of unique chirps from LUT, the fixed delta increment (Delta dither) can be done every N chirps. <br />
</li>
<li>The set of chirp parameters across bursts and sub-frames can be different by setting offset to LUT in BURST_LUT_INDEX_OFFSET and SF_LUT_INDEX_OFFSET. <br />
 <dl class="section note"><dt>Note</dt><dd>1 : The Legacy <a class="el" href="group___sensor.html#ga02aca718122731c4376e25eeefe6ed5e">rlSetChirpConfig</a>, <a class="el" href="group___sensor.html#ga894bc8ce4536062a05aac4248334c964">rlSetDynChirpCfg</a>, <a class="el" href="group___sensor.html#gaf9450d508e0fa2857f8f9cb6b5004ecc">rlRfSetPhaseShiftConfig</a> , <a class="el" href="group___sensor.html#ga37cb66bac3ce58d418d45a9e0ad26e53">rlSetDynPerChirpPhShifterCfg</a> and <a class="el" href="group___sensor.html#ga8ed1335fefa3bf89690418cfe6a379bd">rlSetBpmChirpConfig</a> APIs are not supported if device is configured with Advanced Chirp Config API enabled in AWR_RF_RADAR_MISC_CTL_SB or vice versa. <br />
</dd>
<dd>
2 : The per chirp phase shifter and BPM configurations are part of this API. <br />
</dd>
<dd>
3 : The parameters in this API are not applicable to loop-back sub-frames <a class="el" href="group___sensor.html#ga26c4e8543f1b2c6acdab8714e77220d7">rlSetLoopBckBurstCfg</a>. If loop-back sub-frames are needed, it is recommended to be configured in the last sub-frame (SF) of <a class="el" href="group___sensor.html#ga260d9e27b7b75c3cd33266a16f197ce7">rlSetAdvFrameConfig</a> API. <br />
</dd>
<dd>
4 : The dynamic update of this API is allowed at frame boundary along with the Generic SW Chirp Parameters, as long as the LUT addresses modified differ from the addresses used in the current ongoing frame. The dynamic chirp enable API AWR_DYN_CHIRP_ENABLE_SB shall be issued at least 500us before end of current active window of frame (500us before start of idle time of the frame) to apply the dynamic configurations in immediate next frame. <br />
</dd>
<dd>
5 : If fixed delta dither is used to generate the pattern then it is recommended to program same start frequency in profile config API for each chirps in a frame. Each chirp can have different profiles associated with it except start frequency. <br />
</dd>
<dd>
6 : The number of chirps programmed in a burst/frame shall be multiple of 4. <br />
 Exception: a single chirp can be programmed in a burst. <br />
</dd>
<dd>
7 : The RF frequency used for measurement in monitors are derived only from profile settings (start frequency and slope) and not from the advance chirp configuration API, if fixed delta increment is used to change the start frequency every chirp, it is recommended to have a separate profile for monitors which covers full RF bandwidth of interest. <br />
</dd>
<dd>
8 : All the fields in this API are specific to selected CHIRP_PARAM_INDEX in this API, this API needs to be programmed ten times for each of the chirp parameters defined in CHIRP_PARAM_INDEX field in below API. <br />
</dd>
<dd>
9 : The Delta Dither is optional and can be disabled by setting DELTA_PARAM_UPDATE_PERIOD (N) = 0 and SFn_CHIRP_PARAM_DELTA = 0. <br />
</dd>
<dd>
10: The LUT Dither is mandatory and at least one dither parameter value (it can be value zero) shall be programmed for all chirp parameters in generic LUT, same dither value can be programmed to all chirps in a burst/frame by setting LUT_PARAM_UPDATE_PERIOD (K) = 0. <br />
</dd></dl>
</li>
</ol>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l03794">3794</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga6db6ccd30ed226d5574913adfc6f39a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6db6ccd30ed226d5574913adfc6f39a0">&#9670;&nbsp;</a></span>rlSetAdvChirpDynLUTAddrOffConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetAdvChirpDynLUTAddrOffConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_adv_chirp_dyn_l_u_t_addr_off_cfg__t.html">rlAdvChirpDynLUTAddrOffCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure LUT address offset dynamically for each chirp parameters defined in <a class="el" href="group___sensor.html#ga3c1fe92af102850c9889e77437159a80">rlSetAdvChirpConfig</a> API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- structure contains adv-chirp dynamic LUT address offset configs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API helps to update only the LUT offset address for chirp parameters when LUT data is modified at frame boundary dynamically while frames are running. <br />
The dynamic chirp enable API AWR_DYN_CHIRP_ENABLE_SB shall be issued after issuing this API at least 500us before end of current active window of frame (500us before start of idle time of the frame) to apply the dynamic configurations in immediate next frame. <br />
</p>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l04139">4139</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga0fa71180355fd68a6b87bed87b39ef6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fa71180355fd68a6b87bed87b39ef6c">&#9670;&nbsp;</a></span>rlSetAdvChirpLUTConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetAdvChirpLUTConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_adv_chirp_l_u_t_cfg__t.html">rlAdvChirpLUTCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Advanced chirp LUT configuration to the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- structure contains adv-chirp configs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API sub-block loads the unique dither values for each chirp on Generic SW Chirp Parameter LUT at offset address defined in AWR_ADVANCE_CHIRP_CONF_SB API. This LUT can be used to pre-load dither patterns for each chirp parameters and provides the flexibility to program any number of unique dithers for each chirp parameters. <br />
 </p><dl class="section note"><dt>Note</dt><dd>1 : The Generic SW Chirp Parameter LUT can be modified by the host dynamically, as long as the LUT addresses modified differ from the addresses used in the current frame. <br />
</dd>
<dd>
2 : The dynamic update of this API is effective immediately and does not depend on AWR_DYN_CHIRP_ENABLE_SB API. This might impact the ongoing chirps if timing of the update is not handled properly as if ongoing chirps use same fields/addresses in LUT. It is recommended to perform proper timing analysis before updating the LUT dynamically considering SPI communication delays. <br />
</dd>
<dd>
3 : The total size of Generic SW Chirp Parameter LUT is 12kB. <br />
</dd>
<dd>
4 : The start address offset of all chirp parameter in LUT shall be multiple of 4 bytes (word boundary), that means minimum 4 bytes in LUT shall be allocated to each chirp parameter. <br />
</dd>
<dd>
5 : At least one dither parameter value shall be programmed for each chirp parameter type (10 types) in generic LUT, same value can be programmed to all chirps in a burst/frame using Advance chirp config API, LUT_PARAM_UPDATE_PERIOD (K) = 0 configuration<br />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l03961">3961</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga260d9e27b7b75c3cd33266a16f197ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga260d9e27b7b75c3cd33266a16f197ce7">&#9670;&nbsp;</a></span>rlSetAdvFrameConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetAdvFrameConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_adv_frame_cfg__t.html">rlAdvFrameCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets Advance Frame Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Container for Advance Frame Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function allows configuration of advance frame in mmWave Front end. Advance Frame is a sequence of chirps and how this sequnece needs to be repeated over time. User first need to define a profile and set of chirps(associated with a profile).<br />
 This function then defines how to sequence these chirps. Multiple chirps can be looped to create a burst. Multiple bursts can be grouped to create a sub-frame. Multiple sub-frames(Upto 4) can be grouped to create advance frame. <br />
 This function defines the advance frame properties like the number of burst in subframe, number of chirps and loops in a burst, sequence of subframes to be transmitted, number of frames to be transmitted, periodicity of the frame and the trigger method. This API calls internally two APIs, one to RadraSS for sensor configuraion and another to MasterSS for datapath configuraion. <br />
 </p><dl class="section note"><dt>Note</dt><dd>1: If hardware trigger mode is used with subFrameTrigger = 0, then the trigger should be issued for each burst. If subFrameTrigger = 1, then the trigger needs to be issued for each sub-frame. </dd>
<dd>
2: If hardware triggered mode is used, the SYNC IN pulse width should be less than the ON time of the frame (in case of legacy frame config mode) or the ON time of the burst (in case of advanced frame config mode). Also, the minimum pulse width of SYNC IN should be 25 ns. </dd>
<dd>
3: If frame trigger delay is used with hardware triggered mode, then external SYNC IN pulse periodicity should take care of the configured frame trigger delay and frame periodicity. The external pulse should be issued only after the sum total of frame trigger delay and frame periodicity. </dd>
<dd>
4: In Hw triggered mode, the Hw pulse should be issued or periodicity of pulse is configured such that, the pulse is generated only 150us after the completion of previous frame/burst (The pulse should not be issued before end of previous frame/ burst). The time delta between end of previous frame/burst and raising edge of Hw pulse recommended to be &lt; 300us. </dd>
<dd>
5: The PF_NUM_ADC_SAMPLES parameter should be identical across chirps in a sub-frame, when multiple profiles are used in a sub-frame. <br />
</dd>
<dd>
6: The PF_DIGITAL_OUTPUT_SAMPLING_RATE impacts the LVDS/CSI2 data rate in a sub-frame, so it is recommended to analyze timing impact if different sample rate is used across chirps in a sub-frame. <br />
</dd>
<dd>
7: Please refer Table <a class="el" href="group___sensor.html#interBurstTime">interBurstTime</a> and <a class="el" href="group___sensor.html#interSubFrameTime">interSubFrameTime</a> for details on minimum inter-frame blank time requirements. <br />
</dd>
<dd>
8: If advance chirp configuration is enabled then this API takes around 1.8ms to execute in RadarSS sub System for 128 chirps. The error checks for each parameters of advance chirp is done in frame configuration API. This option can be disabled by using ADVANCE_CHIRP_ERROR_CHK_DIS option in <a class="el" href="group___sensor.html#ga8c3ef75c1d3da0a4134f6929107930e8">rlRfSetMiscConfig</a> API. <br />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l01178">1178</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga8ed1335fefa3bf89690418cfe6a379bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ed1335fefa3bf89690418cfe6a379bd">&#9670;&nbsp;</a></span>rlSetBpmChirpConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetBpmChirpConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_bpm_chirp_cfg__t.html">rlBpmChirpCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets Binary Phase Modulation Chirp Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Container for BPM chirp configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API defines static configurations related to BPM (Binary Phase Modulation) feature in each of the TXs</p>
<dl class="section note"><dt>Note</dt><dd>1: BPM values are configured using TX phase shifter and applied at TX start time. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l00237">237</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="gab1e0e3e2b0cf4ba51b6f14b42f3ae173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1e0e3e2b0cf4ba51b6f14b42f3ae173">&#9670;&nbsp;</a></span>rlSetBpmCommonConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetBpmCommonConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_bpm_common_cfg__t.html">rlBpmCommonCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets Binary Phase Modulation Common Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Container for BPM common Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API defines static configurations related to BPM (Binary Phase Modulation) feature in each of the TXs. E.g. the source of the BPM pattern (one constant value for each chirp as defined, or intra-chirp pseudo random BPM pattern as found by a programmable LFSR or a programmable sequence inside each chirp), are defined here.</p>
<dl class="section note"><dt>Note</dt><dd>1: Different source of BPM is currently not supported, hence this API is not required to be called by application. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l00196">196</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga71a59b160bf9b7a688bad4ed24fdc1f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71a59b160bf9b7a688bad4ed24fdc1f6">&#9670;&nbsp;</a></span>rlSetChannelConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetChannelConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_chan_cfg__t.html">rlChanCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Rx and Tx Channel Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Container for Channel Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function allows configuration of mmWave Front end for how many Receiver and Transmit channels need to be enabled. It also defines whether to to enable single mmWave device or multiple mmWave devices to realize a larger antenna array (multiple is applicable only in AWR2243). This is applicable for given power cycle.</p>
<dl class="section note"><dt>Note</dt><dd>This is global configuration for transmit channels. Later one can chose which transmit channel to be used for each chirp using Chirp configuaration API. For e.g - If Chirp 0, uses TX0 and TX1, and Chirp 1 uses TX1 and TX2, One need to enable TX0, TX1 and TX2 in this API. Based on the configuration, mmWave Front would do necessary calibration before the transmit channel is used to transmit chirps <a class="el" href="group___sensor.html#ga02aca718122731c4376e25eeefe6ed5e">rlSetChirpConfig</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l00106">106</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga02aca718122731c4376e25eeefe6ed5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02aca718122731c4376e25eeefe6ed5e">&#9670;&nbsp;</a></span>rlSetChirpConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetChirpConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rlUInt16_t&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_chirp_cfg__t.html">rlChirpCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets Chirp Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cnt</td><td>- Number of configurations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Array of Chirp Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function sets the chirp to chirp variations on top of the chirp profile. The User should first define a profile using rlSetProfileConfig. This function then configures the chirp by associating it with a particular profile defined in rlSetProfileConfig API. In addition to that user can define fine dither to the profile parameters using this API. The dithers used in this configuration are only additive on top of programmed parameters in rlSetProfileConfig. This API allows configuration of 1 or upto 512 chirps. Also it allows configuraiton of which Transmit channels to be used for each chirp.</p>
<dl class="section note"><dt>Note</dt><dd>1: One can set upto 512 unique chirps which can be stored in dedicated memory inside mmWave front end. Hence user doesn't need to program the chirps during run time. Also these chirps can be sequenced in a frame using rlSetFrameConfig to create a larger FMCW signal.</dd></dl>
<p><a class="el" href="group___sensor.html#gaf1e5cbc25891714db321da3bfa0d2014">rlSetFrameConfig</a> </p>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l00589">589</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga7436761acc24664420be7cc4561e3757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7436761acc24664420be7cc4561e3757">&#9670;&nbsp;</a></span>rlSetContModeConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetContModeConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_cont_mode_cfg__t.html">rlContModeCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets Continous mode Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Continous mode Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function sets the FMCW radar continous mode properties like Start Freq, TX power etc. In continuous mode, the signal is not frequency modulated but has the same frequency over time.</p>
<dl class="section note"><dt>Note</dt><dd>: The continuous streaming mode configuration APIs are supported only for debug purpose. Please refer latest DFP release note for more info. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l01297">1297</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga894bc8ce4536062a05aac4248334c964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga894bc8ce4536062a05aac4248334c964">&#9670;&nbsp;</a></span>rlSetDynChirpCfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetDynChirpCfg </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rlUInt16_t&#160;</td>
          <td class="paramname"><em>segCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_dyn_chirp_cfg__t.html">rlDynChirpCfg_t</a> **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Injects chirp configuration to be programmed dynamically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">segCnt</td><td>- number of segments for which application sends array of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Dynamic chirp configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API can be used to dynamically change the chirp configuration while frames are on-going. The configuration will be stored in software and at rlDynChirpEnCfg API invocation radarSS copies these chirp configurations from SW RAM to HW RAM at the end of current on-going frame.</p>
<dl class="section note"><dt>Note</dt><dd>: The new feature of dynamic chirp configuaration to configuare 48 chirps in one API is not applicable in xWR6843. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l02845">2845</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="gac24c37a764127e473cfa9c81320b31e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac24c37a764127e473cfa9c81320b31e9">&#9670;&nbsp;</a></span>rlSetDynChirpEn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetDynChirpEn </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_dyn_chirp_en_cfg__t.html">rlDynChirpEnCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triggers copy of chirp config from SW to HW RAM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Dynamic chirp enable configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API can be used to trigger the copy of chirp configuration from software to hardware RAM. The copy will be performed at the end of the ongoing frame active window (start of the frame idle time). <br />
</p><dl class="section note"><dt>Note</dt><dd>1: User needs to invoke this API within inter-frame idle time, not at boundary of frame end. Since dynamic chirps are configured at run time, there is not error checks done on the input data. If input data is out of range or invalid, device might misbehave. </dd>
<dd>
2: HW reconfiguration time is around 500 us. User has to ensure that AWR_DYN_CHIRP_ENABLE_SB API is issued at least 500 us before the end of the ongoing frame active window (start of the frame idle time) to apply configurations for next frame onwards. <br />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l02968">2968</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga37cb66bac3ce58d418d45a9e0ad26e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37cb66bac3ce58d418d45a9e0ad26e53">&#9670;&nbsp;</a></span>rlSetDynPerChirpPhShifterCfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetDynPerChirpPhShifterCfg </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rlUInt16_t&#160;</td>
          <td class="paramname"><em>segCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_dyn_per_chirp_ph_shft_cfg__t.html">rlDynPerChirpPhShftCfg_t</a> **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Injects per-chirp phase shifter configuration to be applied dynamically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">segCnt</td><td>- number of segments for which application sends array of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Dynamic chirp configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API can be used to dynamically change the per-chirp phase shifter configuration while frames are on-going. The configuration will be stored in software and the new configuration will be applied at the end of the on-going frame. Note that the configuration should be received by the firmware 10 ms before the end of the current frame.</p>
<dl class="section note"><dt>Note</dt><dd>1: This API is valid only for AWR1243P/2243 mmWave device when mmWaveLink instance is running on External Host Processor. </dd>
<dd>
2: Phase shifter(PS) settings are applied in advance at max -5us or at -(idleTimeConst-1.28us-DfeLagTime) from the knee of the ramp. If idle time &gt; 6.28us, then PS is applied always at -5us and if idle time &lt; 6.28us, then PS is applied at -(idleTimeConst-1.28us-DfeLagTime) from knee of the ramp. Where DfeLagTime is internal DFE lag time (Please refer rampgen calculator). </dd>
<dd>
3: It is recommended to configure TX start time &gt; -5us or -(idleTimeConst-1.28us-DfeLagTime) based on PS apply time. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l03016">3016</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="gaf1e5cbc25891714db321da3bfa0d2014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1e5cbc25891714db321da3bfa0d2014">&#9670;&nbsp;</a></span>rlSetFrameConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetFrameConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_frame_cfg__t.html">rlFrameCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets Frame Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Container for Frame Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function allows configuration of FMCW frame in mmWave Front end. A Frame is basically a sequence of chirps and how this sequnece needs to be repeated over time. User first need to define a profile and set of chirps(associated with a profile). <br />
 This function then defines how to sequence these chirps. The same chirp can be simply looped to create a large FMCW frame or multiple unique chirps cane be sequenced to create the frame. Chirp Start and end Index defines how to sequence them in a frame. <br />
 The API also allows configuration of number of frames to be transmitted, periodicity of the frame and the trigger method. The trigger method could be SW API based trigger or HW SYNC IN based trigger. <br />
 This API calls internally two APIs, one to RadraSS for sensor configuraion and another to MasterSS for datapath configuraion. <br />
 </p><dl class="section note"><dt>Note</dt><dd>1: If hardware triggered mode is used, the SYNC_IN pulse width should be less than the ON time of the frame (in case of legacy frame config mode) or the ON time of the burst (in case of advanced frame config mode). Also, the minimum pulse width of SYNC_IN should be 25 ns. </dd>
<dd>
2: If frame trigger delay is used with hardware triggered mode, then external SYNC_IN pulse periodicity should take care of the configured frame trigger delay and frame periodicity. The external pulse should be issued only after the sum total of frame trigger delay and frame periodicity. </dd>
<dd>
3: If dummy chirp is used then programmer should make sure the idle time of dummy chirp &gt;= 4us + DFE spill over time of previous chirp (calculate from rampgen calculator). The first chirp of frame cannot be a dummy chirp. </dd>
<dd>
4: In Hw triggered mode, the Hw pulse should be issued or periodicity of pulse is configured such that, the pulse is generated only 150us after the completion of previous frame/burst (The pulse should not be issued before end of previous frame/ burst). The time delta between end of previous frame/burst and raising edge of HW pulse recommended to be &lt; 300us. </dd>
<dd>
5: Frame could have multiple chirps associated with different profile, but number of samples need to be same in all the profiles. <br />
</dd>
<dd>
6: The PF_NUM_ADC_SAMPLES parameter should be identical across chirps in a frame, when multiple profiles are used in a frame. <br />
</dd>
<dd>
7: The PF_DIGITAL_OUTPUT_SAMPLING_RATE impacts the LVDS/CSI2 data rate in a frame, so it is recommended to analyze timing impact if different sample rate is used across chirps in a frame. <br />
</dd>
<dd>
8: Please refer Table <a class="el" href="group___sensor.html#interSubFrameTime">interSubFrameTime</a> for details on minimum inter-frame blank time requirements. <br />
</dd>
<dd>
9: If advance chirp configuration is enabled then this API takes around 1.8ms to execute in RadarSS sub System for 128 chirps. The error checks for each parameters of advance chirp is done in frame configuration API. This option can be disabled by using ADVANCE_CHIRP_ERROR_CHK_DIS option in <a class="el" href="group___sensor.html#ga8c3ef75c1d3da0a4134f6929107930e8">rlRfSetMiscConfig</a> API. <br />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l01007">1007</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="gaed3f172d9edbee35db9520b87485f525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed3f172d9edbee35db9520b87485f525">&#9670;&nbsp;</a></span>rlSetGpAdcConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetGpAdcConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_gp_adc_cfg__t.html">rlGpAdcCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: Configure GP ADC data parameters </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Configuration parameter for GP ADC</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API enables the GPADC reads for external inputs (available only in xWR1642/xWR6843/ xWR1843). xWR1642/xWR1843 sends GP-ADC measurement data in async event RL_RF_AE_GPADC_MEAS_DATA_SB</p>
<dl class="section note"><dt>Note</dt><dd>: The actual measurement of these GPADC signal are done in inter-burst or frame idle time and the result AE sub block will be sent only after completing all the measurements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l01898">1898</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga3b6120aed27414c89bc5d27a0e9a22d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b6120aed27414c89bc5d27a0e9a22d6">&#9670;&nbsp;</a></span>rlSetInterChirpBlkCtrl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetInterChirpBlkCtrl </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_inter_chirp_blk_ctrl_cfg__t.html">rlInterChirpBlkCtrlCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets Inter-chip turn on and turn off times or various RF blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Inter chirp block control config</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API programs the Inter-chip turn on and turn off times or various RF blocks </p><dl class="section note"><dt>Note</dt><dd>The minimum inter-chirp time should be greater than maximum of the following<ol type="1">
<li>abs(rx02RfTurnOffTime) + max(abs(rx02RfPreEnTime), abs(rx02RfTurnOnTime))</li>
<li>abs(rx13RfTurnOffTime) + max(abs(rx13RfPreEnTime), abs(rx13RfTurnOnTime))</li>
<li>abs(rx02BbTurnOffTime) + max(abs(rx02BbPreEnTime), abs(rx02BbTurnOnTime))</li>
<li>abs(rx13BbTurnOffTime) + max(abs(rx13BbPreEnTime), abs(rx13BbTurnOnTime))</li>
<li>abs(rxLoChainTurnOffTime) + abs(rxLoChainTurnOnTime)</li>
<li>abs(txLoChainTurnOffTime) + abs(txLoChainTurnOnTime)</li>
</ol>
</dd>
<dd>
: The inter-chirp timing control configuration API is supported in this release. Please refer latest DFP release note for more info. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l03380">3380</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga26c4e8543f1b2c6acdab8714e77220d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26c4e8543f1b2c6acdab8714e77220d7">&#9670;&nbsp;</a></span>rlSetLoopBckBurstCfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetLoopBckBurstCfg </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_loopback_burst__t.html">rlLoopbackBurst_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to introduce loopback chirps within the functional frames. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Loopback chirp config</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API can be used to introduce loopback chirps within the functional frames. This loopback chirps will be introduced only if advanced frame configuration is used where user can define which sub-frame contains loopback chirps. The following loopback configuration will apply to one burst and user can program up to 16 different loopback configurations in 16 different bursts of a given sub-frame. User has to ensure that the corresponding sub-frame is defined in rlSetAdvFrameConfig and sufficient time is given to allow the loopback bursts to be transmitted.</p>
<dl class="section note"><dt>Note</dt><dd>1: If user desires to enable loopback chirps within functional frames, then this API should be issued before rlSetProfileConfig </dd>
<dd>
2: Only profile based phase shifter is supported in loopback configuration. Per-chirp phase shifter if enabled will not be reflected in loopback chirps. </dd>
<dd>
3: For the sub-frame in which loopback is desired, user should set numOfChirps per burst as 1 and can use numLoops per burst for multiple chirps in the burst. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l02806">2806</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga0ce12087a177926f8423b5bbc03b5254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ce12087a177926f8423b5bbc03b5254">&#9670;&nbsp;</a></span>rlSetLowPowerModeConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetLowPowerModeConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_low_power_mode_cfg__t.html">rlLowPowerModeCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets Low Power Mode Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Container for Low power mode Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function sets the static device configurations of low power options. Sigma Delta ADC root sampling reduces to half the rate to save power in small IF bandwidth applications.</p>
<dl class="section note"><dt>Note</dt><dd>: Low power ADC mode is mandatory on 5 MHz part variant(for e.g. xWR1642), Normally if IF band width &lt;= 7.5MHz then low power mode setting is recommended. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l01380">1380</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="gac234ba46f1f41d506f6f231e3ed4540d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac234ba46f1f41d506f6f231e3ed4540d">&#9670;&nbsp;</a></span>rlSetMultiAdvChirpLUTConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetMultiAdvChirpLUTConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_adv_chirp_l_u_t_cfg__t.html">rlAdvChirpLUTCfg_t</a> *&#160;</td>
          <td class="paramname"><em>AdvChirpLUTCfgArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rlInt8_t *&#160;</td>
          <td class="paramname"><em>AdvChirpLUTData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multi Advanced chirp LUT configuration API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AdvChirpLUTCfgArgs</td><td>- Parameters for Advanced chirp LUT configuaration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AdvChirpLUTData</td><td>- LUT buffer filled with the chirp parameter data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>Multi Advanced chirp LUT configuration API. This API is used to send the programmed LUT RAM data to the device populating the RadarSS LUT. This API takes Chirp LUT buffer from the application and internally chunks to multiple SPI packets (max 256 Bytes each).</p>
<dl class="section note"><dt>Note</dt><dd>: This API is supported only in AWR2243. <br />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l04010">4010</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga9588a836954d95b432b5755dad11243d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9588a836954d95b432b5755dad11243d">&#9670;&nbsp;</a></span>rlSetMultiBpmChirpConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetMultiBpmChirpConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rlUInt16_t&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_bpm_chirp_cfg__t.html">rlBpmChirpCfg_t</a> **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets Binary Phase Modulation configuration for multiple Chirp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cnt</td><td>- number of BPM chirp config data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- pointer to linked list/array of BPM chirp configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>Using this API application can configure multiple BPM chirp configuration in a single call. This API defines static configurations related to BPM (Binary Phase Modulation) feature in each of the TXs. </p>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l00280">280</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="gaabedb7c157bd33891293ad2f99bad138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabedb7c157bd33891293ad2f99bad138">&#9670;&nbsp;</a></span>rlSetMultiChirpCfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetMultiChirpCfg </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rlUInt16_t&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_chirp_cfg__t.html">rlChirpCfg_t</a> **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Injects chirp configuration to be programmed dynamically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cnt</td><td>- number of chirps </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Pointer to Chirp configuration linked list/array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function sets the chirp to chirp variations on top of the chirp profile. The User should first define a profile using rlSetProfileConfig.<br />
 This function then configures the chirp by associating it with a particular profile defined in rlSetProfileConfig API. In addition to that user can define fine dither to the profile parameters using this API <br />
This API allows configuration of 1 or upto 512 chirps. Also it allows configuraiton of which Transmit channels to be used for each chirp.</p>
<dl class="section note"><dt>Note</dt><dd>One can set upto 512 unique chirps which can be stored in dedicated memory inside mmWave front end. Hence user doesn't need to program the chirps during run time. Also these chirps can be sequenced in a frame using rlSetFrameConfig to create a larger FMCW signal<br />
This API is similar to rlSetChirpConfig but gives the flexibility to pass the array of chirp configuration pointers, so chirp configuration memory need not be contiguous. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l00851">851</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="gaadd84f565083150a4c09b28f77cf4294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadd84f565083150a4c09b28f77cf4294">&#9670;&nbsp;</a></span>rlSetProfileConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetProfileConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rlUInt16_t&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_profile_cfg__t.html">rlProfileCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets Chirp profile Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cnt</td><td>- Number of Profiles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Array of Profile Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function sets the chirp profile in mmWave Front end. A profile is like a template which contains coarse information about FMCW signal such as start frequency, chirp slope, chirp duration, TX power etc. The API allows multiple profiles to be set together by passing the array of profile data along with count of profiles.</p>
<dl class="section note"><dt>Note</dt><dd>1: One can set upto 4 profiles. Each profile contains coarse inforamtion. Fine dithering can be added using chirp configuration API </dd>
<dd>
2: This API can be issued dynamically to change profile parameters. Few parameters which cannot be changed are<ol type="1">
<li>numAdcSamples</li>
<li>digOutSampleRate</li>
<li>Programmable filter coefficients </li>
</ol>
</dd>
<dd>
3: Please refer Table <a class="el" href="group___sensor.html#chirpCycleTime">chirpCycleTime</a> for details on minimum chirp duration. </dd>
<dd>
4: The max TX output power back-off only up to 20dB is supported. </dd>
<dd>
5: The RF band used in functional chirp profiles shall be within the limit set in AWR_CAL_MON_FREQUENCY_TX_POWER_LIMITS_SB API. </dd>
<dd>
6: This API takes around 700us to execute in RadarSS sub System </dd>
<dd>
7: Phase shifter(PS) settings are applied in advance at max -5us or at -(idleTimeConst-1.28us-DfeLagTime) from the knee of the ramp. If idle time &gt; 6.28us, then PS is applied always at -5us and if idle time &lt; 6.28us, then PS is applied at -(idleTimeConst-1.28us-DfeLagTime) from knee of the ramp. Where DfeLagTime is internal DFE lag time (Please refer rampgen calculator). </dd>
<dd>
8: It is recommended to configure TX start time &gt; -5us or -(idleTimeConst-1.28us-DfeLagTime) based on PS apply time.</dd></dl>
<p><a class="el" href="group___sensor.html#ga02aca718122731c4376e25eeefe6ed5e">rlSetChirpConfig</a> </p>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l00429">429</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="gad0ac5048a8bc47744a685c8db2b9a3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0ac5048a8bc47744a685c8db2b9a3e7">&#9670;&nbsp;</a></span>rlSetSubFrameStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetSubFrameStart </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_sub_frame_start_cfg__t.html">rlSubFrameStartCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triggers the next sub-frame in software triggered sub-frame mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Sub-frame start config</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API triggers the next sub-frame in software triggered sub-frame mode</p>
<dl class="section note"><dt>Note</dt><dd>1: If the user wishes to trigger each sub-frame independently, then after advanced frame config, the rlSensorStart should be issued once using rlSensorStop. This does not start any sub-frames but it will prepare the hardware for sub-frame trigger. Next any subsequent sub-frame trigger will start the sub-frames. </dd>
<dd>
2: If the user wishes to use sub-frame trigger, he has to ensure that sub-frame trigger command is issued k*N times where k is the number of sub-frames in each frame and N is the number of frames. If the user wishes to stop frames in between, then he has to issue the rlSensorStop only after k*M triggers of sub-frame trigger command (where M is an integer). i.e. rlSensorStop can be issued only at frame boundaries. </dd>
<dd>
3: If software based sub-frame trigger mode is chosen by the user, watchdog feature will not be available. User has to ensure that the watchdog is disabled before enabling the software based sub-frame trigger mode. </dd>
<dd>
4: If sub-frame trigger or hardware trigger mode is used to trigger the frames/sub- frames and if frames need to be stopped before the specified number of frames, then the the frame stop command using rlSensorStop API should be issued while the frame is on-going. If the frames are stopped while the device is idle, it can lead to errors </dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l03431">3431</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="gae5d3076ae4314c75470c5f4c0339ea8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5d3076ae4314c75470c5f4c0339ea8b">&#9670;&nbsp;</a></span>rlSetTestSourceConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetTestSourceConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_test_source__t.html">rlTestSource_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the Test Source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Container for Test source configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API allows configuration of the Test Source in mmWave Front end. A Test source simulates 2 objects at certain position relative to the mmWave device and generates the RAW ADC data. It also simulates velocity of objects, relative position of TX and RX antennas.</p>
<dl class="section note"><dt>Note</dt><dd>1: This helps in checking the integrity of control and data path during development phase. API is meant to be used in development phase only and doesn't relate to any real use case. </dd>
<dd>
2: The test source configuration APIs are supported only for debug purpose. Please refer latest DFP release note for more info. </dd>
<dd>
3: After test source usage, it is recommend to disable the test source and issue profile configuration API again for normal functionality of radar. <br />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l01637">1637</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="ga0cf47018653eb8cbd49adfccf0fc6ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cf47018653eb8cbd49adfccf0fc6ef9">&#9670;&nbsp;</a></span>rlTestSourceEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlTestSourceEnable </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_test_source_enable__t.html">rlTestSourceEnable_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the Test Source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Container for Test source enable parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>Enables the Test Source that is configured using <a class="el" href="group___sensor.html#gae5d3076ae4314c75470c5f4c0339ea8b">rlSetTestSourceConfig</a> API </p>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l01676">1676</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a id="gae129023dfe4ed79d5df1c1001ada7985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae129023dfe4ed79d5df1c1001ada7985">&#9670;&nbsp;</a></span>rlTxGainTempLutSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlTxGainTempLutSet </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_tx_gain_temp_lut_data__t.html">rlTxGainTempLutData_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrites TX gain temperature based Lookup table (LUT) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- TX gain Temperature LUT config</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API can be used to overwrite the TX gain temperature LUT used in Radar SS. This API should be issued after profile configuration API. </p>

<p class="definition">Definition at line <a class="el" href="rl__sensor_8c_source.html#l02654">2654</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2020, Texas Instruments Incorporated</small>
</body>
</html>
